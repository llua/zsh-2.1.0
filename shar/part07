Path: funic!news.funet.fi!sunic!seunet!mcsun!uunet!sparky!kent
From: pfalstad@phoenix.Princeton.EDU (Paul Falstad)
Newsgroups: comp.sources.misc
Subject: v24i007:  zsh2.1 - The Z shell, Part07/19
Message-ID: <1991Oct24.190901.25780@sparky.imd.sterling.com>
Date: 24 Oct 91 19:09:01 GMT
References: <csm-v24i001=zsh2.1.140401@sparky.IMD.Sterling.COM>
Sender: kent@sparky.imd.sterling.com (Kent Landfield)
Followup-To: comp.sources.d
Organization: Sterling Software, IMD
Lines: 2515
Approved: kent@sparky.imd.sterling.com
X-Md4-Signature: 3b9e9db3e226c0bd3652e4886dcb6cca

Submitted-by: pfalstad@phoenix.Princeton.EDU (Paul Falstad)
Posting-number: Volume 24, Issue 7
Archive-name: zsh2.1/part07
Environment: BSD
Supersedes: zsh2.00: Volume 18, Issue 84-98

#!/bin/sh
# this is zshar.07 (part 7 of zsh2.1.0)
# do not concatenate these parts, unpack them in order with /bin/sh
# file zsh2.1/src/glob.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 7; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping zsh2.1/src/glob.c'
else
echo 'x - continuing file zsh2.1/src/glob.c'
sed 's/^X//' << 'SHAR_EOF' >> 'zsh2.1/src/glob.c' &&
X				}
X				if (*pat == Outbrack)
X					break;
X				for (pptr++; *pat != Outbrack; pat++);
X				pat++;
X				continue;
X			}
X		}
X		if (*pat == Inang)
X			{
X			int t1,t2,t3;
X			char *ptr;
X
X			if (*++pat == Outang)	/* handle <> case */
X				{
X				( void ) zstrtol(pptr,&ptr,10);
X				if (ptr == pptr)
X					break;
X				pptr = ptr;
X				pat++;
X				}
X			else
X				{
X				t1 = zstrtol(pptr,&ptr,10);
X				if (ptr == pptr)
X					break;
X				pptr = ptr;
X				t2 = zstrtol(pat,&ptr,10);
X				if (*ptr != '-')
X					exit(31);
X				t3 = zstrtol(ptr+1,&pat,10);
X				if (!t3)
X					t3 = -1;
X				if (*pat++ != Outang)
X					exit(21);
X				if (t1 < t2 || (t3 != -1 && t1 > t3))
X					break;
X				}
X			continue;
X			}
X		if (*pptr == *pat)
X			{
X			pptr++;
X			pat++;
X			continue;
X			}
X		break;
X		}
X	return 0;
X}
X
XComplist parsepat(str) /**/
Xchar *str;
X{
X	mode = 0;
X	pptr = str;
X	return parsecomplist();
X}
X
XComp parsereg(str) /**/
Xchar *str;
X{
X	mode = 1;
X	pptr = str;
X	return parsecompsw();
X}
X
XComplist parsecomplist() /**/
X{
XComp c1;
XComplist p1;
X
X	if (pptr[0] == Star && pptr[1] == Star &&
X		 pptr[2] == Star && pptr[3] == Star &&
X		 pptr[4] == '/')
X		{
X		pptr[0] = Inpar;
X		pptr[1] = Star;
X		pptr[2] = '/';
X		pptr[3] = Outpar;
X		pptr[4] = Pound;	/* "####/" -> "( * /)#" */
X		}
X	if (*pptr == Inpar)
X		{
X		char *str;
X		int pars = 1;
X
X		for (str = pptr+1; *str && pars; str++)
X			if (*str == Inpar)
X				pars++;
X			else if (*str == Outpar)
X				pars--;
X		if (str[0] != Pound || str[-1] != Outpar || str[-2] != '/')
X			goto kludge;
X		pptr++;
X		if (!(c1 = parsecompsw()))
X			return NULL;
X		if (pptr[0] == '/' && pptr[1] == Outpar && pptr[2] == Pound)
X			{
X			int pdflag = 0;
X
X			pptr += 3;
X			if (*pptr == Pound)
X				{
X				pdflag = 1;
X				pptr++;
X				}
X			p1 = (Complist) alloc(sizeof *p1);
X			p1->comp = c1;
X			p1->closure = 1+pdflag;
X			p1->next = parsecomplist();
X			return (p1->comp) ? p1 : NULL;
X			}
X		}
X	else
X		{
Xkludge:
X		if (!(c1 = parsecompsw()))
X			return NULL;
X		if (*pptr == '/' || !*pptr)
X			{
X			int ef = *pptr == '/';
X
X			p1 = (Complist) alloc(sizeof *p1);
X			p1->comp = c1;
X			p1->closure = 0;
X			p1->next = (*pptr == '/') ? (pptr++,parsecomplist()) : NULL;
X			return (ef && !p1->next) ? NULL : p1;
X			}
X		}
X	errflag = 1;
X	return NULL;
X}
X
XComp parsecomp() /**/
X{
XComp c = (Comp) alloc(sizeof *c),c1,c2;
Xchar *s = c->str = alloc(MAXPATHLEN*2),*ls = NULL;
X
X	c->next = tail;
X
X	while (*pptr && (mode || *pptr != '/') && *pptr != Bar &&
X			*pptr != Outpar)
X		{
X		if (*pptr == Hat)
X			{
X			*s++ = Hat;
X			*s++ = '\0';
X			pptr++;
X			if (!(c->next = parsecomp()))
X				return NULL;
X			return c;
X			}
X		if (*pptr == Star && pptr[1] && (mode || pptr[1] != '/'))
X			{
X			*s++ = '\0';
X			pptr++;
X			c1 = (Comp) alloc(sizeof *c1);
X			*(c1->str = strdup("?")) = Quest;
X			c1->closure = 1;
X			if (!(c2 = parsecomp())) return NULL;
X			c1->next = c2;
X			c->next = c1;
X			return c;
X			}
X		if (*pptr == Inpar)
X			{
X			int pars = 1;
X			char *startp = pptr, *endp;
X			Comp stail = tail;
X			int dpnd = 0;
X
X			for (pptr = pptr+1; *pptr && pars; pptr++)
X				if (*pptr == Inpar)
X					pars++;
X				else if (*pptr == Outpar)
X					pars--;
X			if (pptr[-1] != Outpar)
X				{
X				errflag = 1;
X				return NULL;
X				}
X			if (*pptr == Pound)
X				{
X				dpnd = 1;
X				pptr++;
X				if (*pptr == Pound)
X					{
X					pptr++;
X					dpnd = 2;
X					}
X				}
X			if (!(c1 = parsecomp())) return NULL;
X			tail = c1;
X			endp = pptr;
X			pptr = startp;
X			pptr++;
X			*s++ = '\0';
X			c->next = (Comp) alloc(sizeof *c);
X			c->next->left = parsecompsw();
X			c->next->closure = dpnd;
X			c->next->next = (Comp) alloc(sizeof *c);
X			pptr = endp;
X			tail = stail;
X			return c;
X			}
X		if (*pptr == Pound)
X			{
X			*s = '\0';
X			pptr++;
X			if (!ls)
X				return NULL;
X			if (*pptr == Pound) 
X				{
X				pptr++;
X				c->next = c1 = (Comp) alloc(sizeof *c);
X				c1->str = strdup(ls);
X				}
X			else
X				c1 = c;
X			c1->next = c2 = (Comp) alloc(sizeof *c);
X			c2->str = strdup(ls);
X			c2->closure = 1;
X			c2->next = parsecomp();
X			if (!c2->next)
X				return NULL;
X			*ls++ = '\0';
X			return c;
X			}
X		ls = s;
X		if (*pptr == Inang)
X			{
X			int dshct;
X
X			dshct = (pptr[1] == Outang);
X			*s++ = *pptr++;
X			while (*pptr && (*s++ = *pptr++) != Outang)
X				if (s[-1] == '-')
X					dshct++;
X				else if (!idigit(s[-1]))
X					break;
X			if (s[-1] != Outang || dshct != 1)
X				return NULL;
X			}
X		else if (*pptr == Inbrack)
X			{
X			while (*pptr && (*s++ = *pptr++) != Outbrack);
X			if (s[-1] != Outbrack)
X				return NULL;
X			}
X		else if (itok(*pptr) && *pptr != Star && *pptr != Quest)
X			*s++ = ztokens[*pptr++-Pound];
X		else
X			*s++ = *pptr++;
X		}
X	if (*pptr == '/' || !*pptr)
X		c->last = 1;
X	*s++ = '\0';
X	return c;
X}
X
XComp parsecompsw() /**/
X{
XComp c1,c2,c3;
X
X	c1 = parsecomp();
X	if (!c1)
X		return NULL;
X	if (*pptr == Bar)
X		{
X		c2 = (Comp) alloc(sizeof *c2);
X		pptr++;
X		c3 = parsecompsw();
X		if (!c3)
X			return NULL;
X		c2->str = strdup("");
X		c2->left = c1;
X		c2->right = c3;
X		return c2;
X		}
X	return c1;
X}
X
X/* tokenize and see if ss matches tt */
X
Xint patmatch(ss,tt) /**/
Xchar *ss;char *tt;
X{
Xchar *s = ss,*t;
X
X	for (; *s; s++)
X		if (*s == '\\')
X			chuck(s);
X		else
X			for (t = ztokens; *t; t++)
X				if (*t == *s)
X					{
X					*s = (t-ztokens)+Pound;
X					break;
X					}
X	return matchpat(ss,tt);
X}
X
X/* remove unnecessary Nulargs */
X
Xvoid remnulargs(s) /**/
Xchar *s;
X{
Xint nl = *s;
Xchar *t = s;
X
X	while (*s)
X		if (*s == Nularg)
X			chuck(s);
X		else
X			s++;
X	if (!*t && nl)
X		{
X		t[0] = Nularg;
X		t[1] = '\0';
X		}
X}
X
X/* qualifier functions */
X
Xint qualdev(buf,dv) /**/
Xstruct stat *buf;long dv;
X{
X	return buf->st_dev == dv;
X}
X
Xint qualnlink(buf,ct) /**/
Xstruct stat *buf;long ct;
X{
X	return buf->st_nlink == ct;
X}
X
Xint qualuid(buf,uid) /**/
Xstruct stat *buf;long uid;
X{
X	return buf->st_uid == uid;
X}
X
Xint qualgid(buf,gid) /**/
Xstruct stat *buf;long gid;
X{
X	return buf->st_gid == gid;
X}
X
Xint qualisdev(buf,junk) /**/
Xstruct stat *buf;long junk;
X{
X	junk = buf->st_mode & S_IFMT;
X	return junk == S_IFBLK || junk == S_IFCHR;
X}
X
Xint qualmode(buf,mod) /**/
Xstruct stat *buf;long mod;
X{
X	return (buf->st_mode & S_IFMT) == mod;
X}
X
Xint qualflags(buf,mod) /**/
Xstruct stat *buf;long mod;
X{
X	return buf->st_mode & mod;
X}
X
Xint qualiscom(buf,mod) /**/
Xstruct stat *buf;long mod;
X{
X	return (buf->st_mode & (S_IFMT|S_IEXEC)) == (S_IFREG|S_IEXEC);
X}
X
SHAR_EOF
echo 'File zsh2.1/src/glob.c is complete' &&
chmod 0644 zsh2.1/src/glob.c ||
echo 'restore of zsh2.1/src/glob.c failed'
Wc_c="`wc -c < 'zsh2.1/src/glob.c'`"
test 23323 -eq "$Wc_c" ||
	echo 'zsh2.1/src/glob.c: original size 23323, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.1/src/hist.c ==============
if test -f 'zsh2.1/src/hist.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.1/src/hist.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.1/src/hist.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.1/src/hist.c' &&
X/*
X
X	hist.c - history expansion
X
X	This file is part of zsh, the Z shell.
X
X	zsh is free software; no one can prevent you from reading the source
X   code, or giving it to someone else.
X
X   This file is copyrighted under the GNU General Public License, which
X   can be found in the file called COPYING.
X
X   Copyright (C) 1990, 1991 Paul Falstad
X
X   zsh is distributed in the hope that it will be useful, but
X   WITHOUT ANY WARRANTY.  No author or distributor accepts
X   responsibility to anyone for the consequences of using it or for
X   whether it serves any particular purpose or works at all, unless he
X   says so in writing.  Refer to the GNU General Public License
X   for full details.
X
X   Everyone is granted permission to copy, modify and redistribute
X   zsh, but only under the conditions described in the GNU General Public
X   License.   A copy of this license is supposed to have been given to you
X   along with zsh so you can know your rights and responsibilities.
X   It should be in a file named COPYING.
X
X   Among other things, the copyright notice and this notice must be
X   preserved on all copies.
X
X*/
X
X#include "zsh.h"
X
Xstatic int lastc;
X
X/* add a character to the current history word */
X
Xvoid hwaddc(c) /**/
Xint c;
X{
X	if (hlastw && hline && (!(errflag || lexstop) || c == HISTSPACE))
X		{
X		*hptr++ = c;
X		if (hptr-hline >= hlinesz)
X			{
X			int ll,flag = 0;
X
X			ll = hptr-hlastw;
X			if (full(histlist) && getdata(lastnode(histlist)) == hline)
X				flag = 1;
X			hline = realloc(hline,hlinesz *= 4);
X			if (flag)
X				setdata(lastnode(histlist),hline);
X			hptr = hline+(hlinesz/4);
X			hlastw = hptr-ll;
X			}
X		}
X}
X
X#define habort() { errflag = lexstop = 1; return ' '; }
X
X/* get a character after performing history substitution */
X
Xint hgetc() /**/
X{
Xint c,ev,farg,larg,argc,marg = -1,cflag = 0,bflag = 0;
Xchar buf[256],*ptr;
Xchar *sline,*eline;
X
Xtailrec:
X	c = hgetch();
X	if (stophist || alstackind)
X		{
X		hwaddc(c);
X		return c;
X		}
X	if (isfirstch && c == hatchar)
X		{
X		isfirstch = 0;
X		hungetch(hatchar);
X		hungets(":s");
X		c = bangchar;
X		goto hatskip;
X		}
X	if (c != ' ')
X		isfirstch = 0;
X	if (c == '\\')
X		{
X		int g = hgetch();
X		
X		if (g != bangchar)
X			hungetch(g);
X		else
X			{
X			hwaddc(bangchar);
X			return bangchar;
X			}
X		}
X	if (c != bangchar)
X		{
X		hwaddc(c);
X		return c;
X		}
Xhatskip:
X	*hptr = '\0';
X	if ((c = hgetch()) == '{')
X		{
X		bflag = cflag = 1;
X		c = hgetch();
X		}
X	if (c == '\"')
X		{
X		stophist = 1;
X		goto tailrec;
X		}
X	if (!cflag && inblank(c) || c == '=' || c == '(' || lexstop)
X		{
X		if (lexstop)
X			lexstop = 0;
X		else
X			hungetch(c);
X		hwaddc(bangchar);
X		return bangchar;
X		}
X	cflag = 0;
X	ptr = buf;
X
X	/* get event number */
X
X	if (c == '?')
X		{
X		for(;;)
X			{
X			c = hgetch();
X			if (c == '?' || c == '\n' || lexstop)
X				break;
X			else
X				*ptr++ = c;
X			}
X		if (c != '\n' && !lexstop)
X			c = hgetch();
X		*ptr = '\0';
X		ev = hconsearch(hsubl = ztrdup(buf),&marg);
X		if (ev == -1)
X			{
X			herrflush();
X			zerr("no such event: %s",buf,0);
X			habort();
X			}
X		}
X	else
X		{
X		int t0;
X 
X		for (;;)
X			{
X			if (inblank(c) || c == ';' || c == ':' || c == '^' || c == '$' ||
X					c == '*' || c == '%' || c == '}' || lexstop)
X				break;
X			if (ptr != buf) {
X				if (c == '-') break;
X				if (idigit(buf[0]) && !idigit(c)) break;
X			}
X			*ptr++ = c;
X			if (c == '#' || c == bangchar)
X				{
X				c = hgetch();
X				break;
X				}
X			c = hgetch();
X			}
X		*ptr = 0;
X		if (!*buf)
X			ev = defev;
X		else if (t0 = atoi(buf))
X			ev = (t0 < 0) ? curhist+t0 : t0;
X		else if (*buf == bangchar)
X			ev = curhist-1;
X		else if (*buf == '#')
X			ev = curhist;
X		else if ((ev = hcomsearch(buf)) == -1)
X			{
X			zerr("event not found: %s",buf,0);
X			while (c != '\n' && !lexstop)
X				c = hgetch();
X			habort();
X			}
X		}
X
X	/* get the event */
X
X	if (!(eline = getevent(defev = ev)))
X		habort();
X
X	/* extract the relevant arguments */
X
X	argc = getargc(eline);
X	if (c == ':')
X		{
X		cflag = 1;
X		c = hgetch();
X		}
X	if (c == '*')
X		{
X		farg = 1;
X		larg = argc;
X		cflag = 0;
X		}
X	else
X		{
X		hungetch(c);
X		larg = farg = getargspec(argc,marg);
X		if (larg == -2)
X			habort();
X		if (farg != -1)
X			cflag = 0;
X		c = hgetch();
X		if (c == '*')
X			{
X			cflag = 0;
X			larg = argc;
X			}
X		else if (c == '-')
X			{
X			cflag = 0;
X			larg = getargspec(argc,marg);
X			if (larg == -2)
X				habort();
X			if (larg == -1)
X				larg = argc-1;
X			}
X		else
X			hungetch(c);
X		}
X	if (farg == -1)
X		farg = 0;
X	if (larg == -1)
X		larg = argc;
X	if (!(sline = getargs(eline,farg,larg)))
X		habort();
X
X	/* do the modifiers */
X
X	for(;;)
X		{
X		c = (cflag) ? ':' : hgetch();
X		cflag = 0;
X		if (c == ':')
X			{
X			int gbal = 0;
X		
X			if ((c = hgetch()) == 'g')
X				{
X				gbal = 1;
X				c = hgetch();
X				}
X			switch(c)
X				{
X				case 'p':
X					histdone = HISTFLAG_DONE|HISTFLAG_NOEXEC;
X					break;
X				case 'h':
X					if (!remtpath(&sline))
X						{
X						herrflush();
X						zerr("modifier failed: h",NULL,0);
X						habort();
X						}
X					break;
X				case 'e':
X					if (!rembutext(&sline))
X						{
X						herrflush();
X						zerr("modifier failed: e",NULL,0);
X						habort();
X						}
X					break;
X				case 'r':
X					if (!remtext(&sline))
X						{
X						herrflush();
X						zerr("modifier failed: r",NULL,0);
X						habort();
X						}
X					break;
X				case 't':
X					if (!remlpaths(&sline))
X						{
X						herrflush();
X						zerr("modifier failed: t",NULL,0);
X						habort();
X						}
X					break;
X				case 's':
X					{
X					int del;
X					char *ptr1,*ptr2;
X				
X					del = hgetch();
X					ptr1 = hdynread2(del);
X					if (!ptr1)
X						habort();
X					ptr2 = hdynread2(del);
X					if (strlen(ptr1))
X						{
X						if (hsubl)
X							free(hsubl);
X						hsubl = ptr1;
X						}
X					if (hsubr)
X						free(hsubr);
X					hsubr = ptr2;
X					}
X				case '&':
X					if (hsubl && hsubr)
X						subst(&sline,hsubl,hsubr,gbal);
X					else
X						{
X						herrflush();
X						zerr("no previous substitution with &",NULL,0);
X						habort();
X						}
X					break;
X				case 'q':
X					quote(&sline);
X					break;
X				case 'x':
X					quotebreak(&sline);
X					break;
X				case 'l':
X					downcase(&sline);
X					break;
X				case 'u':
X					upcase(&sline);
X					break;
X				default:
X					herrflush();
X					zerr("illegal modifier: %c",NULL,c);
X				habort();
X				break;
X			}
X		}
X	else
X		{
X		if (c != '}' || !bflag)
X			hungetch(c);
X		if (c != '}' && bflag)
X			{
X			zerr("'}' expected",NULL,0);
X			habort();
X			}
X		break;
X		}
X	}
X
X	/* stuff the resulting string in the input queue and start over */
X
X	lexstop = 0;
X	if (alstackind != MAXAL)
X		{
X		hungets(HISTMARK);
X		alstack[alstackind++] = NULL;
X		}
X	hungets(sline);
X	histdone |= HISTFLAG_DONE;
X	if (isset(HISTVERIFY)) {
X		histdone |= HISTFLAG_NOEXEC;
X		zrecall = 1;
X	}
X	goto tailrec;
X}
X
X/* reset the alias stack for lexrestore () */
X
Xvoid clearalstack() /**/
X{
XAlias ix;
X
X	while (alstackind)
X		{
X		ix = alstack[--alstackind];
X		ix->inuse = 0;
X		}
X}
X
X/* get a character without history expansion */
X
Xint hgetch() /**/
X{
Xchar *line,*pmpt,*pmpt2 = NULL;
Xint plen;
X
Xstart:
X	if (inbufct)
X		{
X		inbufct--;
X		if ((lastc = *inbufptr++) == ALPOP)
X			{
X			Alias ix;
X			char *t;
X
X			if (!alstackind)
X				{
X				zerr("alias stack underflow",NULL,0);
X				errflag = lexstop = 1;
X				return lastc = ' ';
X				}
X			ix = alstack[--alstackind];
X			if (ix)
X				{
X				ix->inuse = 0;
X				t = ix->text;
X				if (*t && t[strlen(t)-1] == ' ')
X					alstat = ALSTAT_MORE;
X				else
X					alstat = ALSTAT_JUNK;
X				}
X			goto start;
X			}
X		if (itok(lastc))
X			goto start;
X		return lastc;
X		}
X	if (strin || errflag)
X		{
X		lexstop = 1;
X		return lastc = ' ';
X		}
X	if (interact && isset(SHINSTDIN))
X		if (!isfirstln)
X			pmpt = putprompt(prompt2,&plen);
X		else
X			{
X			int foo;
X
X			pmpt = putprompt(prompt,&plen);
X			pmpt2 = (rprompt) ? putprompt(rprompt,&foo) : NULL;
X			}
X	if (!(interact && isset(SHINSTDIN) && SHTTY != -1 && isset(USEZLE)))
X		{
X		if (interact && isset(SHINSTDIN))
X			write(2,pmpt,strlen(pmpt));
X		line = fgets(zalloc(256),256,bshin);
X		}
X	else
X		line = zleread(pmpt,pmpt2,plen);
X	if (!line)
X		{
X		lexstop = 1;
X		return lastc = ' ';
X		}
X	if (errflag)
X		{
X		lexstop = errflag = 1;
X		return lastc = ' ';
X		}
X	if (interact && isset(SHINSTDIN))
X		{
X		char *s = getdata(lastnode(lithistlist));
X
X		if (!*s)
X			{
X			free(s);
X			setdata(lastnode(lithistlist),ztrdup(line));
X			}
X		else
X			{
X			char *t = zalloc(strlen(s)+strlen(line)+3);
X
X			strcpy(t,s);
X			strcat(t,line);
X			free(s);
X			setdata(lastnode(lithistlist),t);
X			}
X		}
X	if (isfirstln)
X		spaceflag = *line == ' ';
X	if (isset(VERBOSE))
X		{
X		fputs(line,stderr);
X		fflush(stderr);
X		}
X	if (line[strlen(line)-1] == '\n')
X		{
X		lineno++;
X		if (interact && isset(SUNKEYBOARDHACK) && isset(SHINSTDIN) && 
X				SHTTY != -1 && *line && line[1] && line[strlen(line)-2] == '`')
X			{
X			int ct;
X			char *ptr;
X
X			for (ct = 0, ptr = line; *ptr; ptr++)
X				if (*ptr == '`')
X					ct++;
X			if (ct & 1)
X				{
X				ptr[-2] = '\n';
X				ptr[-1] = '\0';
X				}
X			}
X		}
X	isfirstch = 1;
X	hungets(line);
X	free(line);
X	goto start;
X}
X
X/* put a string in the input queue */
X
Xvoid hungets(str) /**/
Xchar *str;
X{
Xint slen = strlen(str);
X
X/* shrink inbuf if it gets too big */
X
X	if (!inbufct && inbufsz > 65536)
X		{
X		free(inbuf);
X		inbuf = zalloc(inbufsz = 256);
X		inbufptr = inbuf+inbufsz;
X		inbufct = 0;
X		}
X	if (slen+inbufct > inbufsz)
X		{
X		char *x;
X
X		while (slen+inbufct > inbufsz)
X			inbufsz *= 4;
X		x = zalloc(inbufsz);
X		memcpy(x+inbufsz-inbufct,inbufptr,inbufct);
X		inbufptr = x+inbufsz-inbufct;
X		free(inbuf);
X		inbuf = x;
X		}
X	memcpy(inbufptr -= slen,str,slen);
X	inbufct += slen;
X}
X
X/* unget a char and remove it from hline */
X
Xvoid hungetc(c) /**/
Xint c;
X{
X	if (lexstop)
X		return;
X	if (hlastw)
X		{
X		if (hlastw == hptr)
X			zerr("hungetc attempted at buffer start",NULL,0);
X		else
X			hptr--;
X		}
X	hungetch(c);
X}
X
Xvoid hungetch(c) /**/
Xint c;
X{
X	if (lexstop)
X		return;
X	if (inbufct == inbufsz)
X		{
X		hungets(" ");
X		*inbufptr = c;
X		}
X	else
X		{
X		*--inbufptr = c;
X		inbufct++;
X		}
X}
X
X/* begin reading a string */
X
Xvoid strinbeg() /**/
X{
X	strin = 1;
X	hbegin();
X	lexinit();
X}
X
X/* done reading a string */
X
Xvoid strinend() /**/
X{
X	strin = 0;
X	isfirstch = 1;
X	histdone = 0;
X	hend();
X}
X
X/* stuff a whole file into the input queue and print it */
X
Xint stuff(fn) /**/
Xchar *fn;
X{
XFILE *in;
Xchar *buf;
Xint len;
X
X	if (!(in = fopen(fn,"r")))
X		{
X		zerr("can't open %s",fn,0);
X		return 1;
X		}
X	fseek(in,0,2);
X	len = ftell(in);
X	fseek(in,0,0);
X	buf = alloc(len+1);
X	if (!(fread(buf,len,1,in)))
X		{
X		zerr("read error on %s",fn,0);
X		fclose(in);
X		free(buf);
X		return 1;
X		}
X	fclose(in);
X	buf[len] = '\0';
X	fwrite(buf,len,1,stdout);
X	hungets(buf);
X	return 0;
X}
X
X/* flush input queue */
X
Xvoid hflush() /**/
X{
X	inbufptr += inbufct;
X	inbufct = 0;
X}
X
X/* initialize the history mechanism */
X
Xvoid hbegin() /**/
X{
X	isfirstln = isfirstch = 1;
X	histremmed = errflag = histdone = spaceflag = 0;
X	stophist = isset(NOBANGHIST);
X	lithist = isset(HISTLIT);
X	hline = hptr = zalloc(hlinesz = 32);
X	if (interact && isset(SHINSTDIN) && !strin) {
X		inittty();
X		defev = curhist++;
X		while (curhist-firsthist >= histsiz) {
X			free(getnode(histlist));
X			firsthist++;
X		}
X		while (curhist-firstlithist >= lithistsiz) {
X			free(getnode(lithistlist));
X			firstlithist++;
X		}
X		permalloc();
X		addnode(histlist,hline);
X		addnode(lithistlist,ztrdup(""));
X		heapalloc();
X	} else
X		histremmed = 1;
X}
X
Xvoid inittty() /**/
X{
X	attachtty(mypgrp);
X}
X
X/* say we're done using the history mechanism */
X
Xint hend() /**/
X{
Xint flag,save = 1;
X
X	if (!hline)
X		return 1;
X	if (!interact || strin || unset(SHINSTDIN)) {
X		free(hline);
X		return 1;
X	}
X	flag = histdone;
X	histdone = 0;
X	if (hptr < hline+2)
X		save = 0;
X	else {
X		char *s = getdata(lastnode(lithistlist));
X
X		if (*s)
X			s[strlen(s)-1] = '\0';
X		hptr[-1] = '\0';
X		if (hptr[-2] == '\n')
X			if (hline[1])
X				hptr[-3] = '\0';
X			else
X				save = 0;
X		if (!strcmp(hline,"\n") ||
X				(isset(HISTIGNOREDUPS) && firstnode(histlist) &&
X				nextnode(firstnode(histlist)) &&
X				!strcmp(hline,getdata(prevnode(lastnode(histlist))))) ||
X				(isset(HISTIGNORESPACE) && spaceflag) )
X			save = 0;
X	}
X	if (flag & HISTFLAG_DONE) {
X		char *ptr,*p;
X
X		p = ptr = ztrdup(hline);
X		for (;*p;p++)
X			if (*p == HISTSPACE)
X				*p = ' ';
X		fprintf(stderr,"%s\n",ptr);
X		fflush(stderr);
X		free(ptr);
X	}
X	if (!save) {
X		free(hline);
X		if (!histremmed) {
X			remnode(histlist,lastnode(histlist));
X			free(remnode(lithistlist,lastnode(lithistlist)));
X			curhist--;
X		}
X	}
X	hline = NULL;
X	return !(flag & HISTFLAG_NOEXEC || errflag);
X}
X
X/* remove the current line from the history List */
X
Xvoid remhist() /**/
X{
X	if (!histremmed)
X		{
X		histremmed = 1;
X		free(remnode(histlist,lastnode(histlist)));
X		free(remnode(lithistlist,lastnode(lithistlist)));
X		curhist--;
X		}
X}
X
X/* begin a word */
X
Xvoid hwbegin() /**/
X{
X	hlastw = hptr;
X}
X
X/* add a word to the history List */
X
Xchar *hwadd() /**/
X{
Xchar *ret = hlastw;
X
X	if (hlastw && hline)
X		{
X		hwaddc(HISTSPACE);
X		if (alstackind || strin)
X			if (!(alstackind == 1 && !alstack[0]))
X				hptr = hlastw;
X		}
X	if (alstat == ALSTAT_JUNK)
X		alstat = 0;
X	return ret;
X}
X
X/* get an argument specification */
X
Xint getargspec(argc,marg) /**/
Xint argc;int marg;
X{
Xint c,ret = -1;
X 
X	if ((c = hgetch()) == '0')
X		return 0;
X	if (idigit(c))
X		{
X		ret = 0;
X		while (idigit(c))
X			{
X			ret = ret*10+c-'0';
X			c = hgetch();
X			}
X		hungetch(c);
X		}
X	else if (c == '^')
X		ret = 1;
X	else if (c == '$')
X		ret = argc;
X	else if (c == '%')
X		{
X		if (marg == -1)
X			{
X			herrflush();
X			zerr("%% with no previous word matched",NULL,0);
X			return -2;
X			}
X		ret = marg;
X		}
X	else
X		hungetch(c);
X	return ret;
X}
X
X/* do ?foo? search */
X
Xint hconsearch(str,marg) /**/
Xchar *str;int *marg;
X{
Xint t0,t1 = 0;
XLknode node;
Xchar *s;
X 
X	if (curhist-firsthist < 1)
X		return -1;
X	for (t0 = curhist-1,node = prevnode(lastnode(histlist));
X			t0 >= firsthist; t0--,node = prevnode(node))
X		if (s = ztrstr(getdata(node),str))
X			{
X			while (s != (char *) getdata(node))
X				if (*s-- == HISTSPACE)
X					t1++;
X			*marg = t1;
X			return t0;
X			}
X	return -1;
X}
X
X/* do !foo search */
X
Xint hcomsearch(str) /**/
Xchar *str;
X{
Xint t0;
XLknode node;
X
X	if (curhist-firsthist < 1)
X		return -1;
X	for (t0 = curhist-1,node = prevnode(lastnode(histlist)); t0 >= firsthist;
X			t0--,node = prevnode(node))
X		if (!strncmp(getdata(node),str,strlen(str)))
X			return t0;
X	return -1;
X}
X
X/* various utilities for : modifiers */
X
Xint remtpath(junkptr) /**/
Xchar **junkptr;
X{
Xchar *str = *junkptr,*cut;
X 
X	if (cut = strrchr(str,'/')) {
X		if (str != cut) *cut = '\0';
X		else str[1] = '\0';
X		return 1;
X	}
X	return 0;
X}
X 
Xint remtext(junkptr) /**/
Xchar **junkptr;
X{
Xchar *str = *junkptr,*cut;
X 
X	if ((cut = strrchr(str,'.')) && cut != str)
X		{
X		*cut = '\0';
X		return 1;
X		}
X	return 0;
X}
X 
Xint rembutext(junkptr) /**/
Xchar **junkptr;
X{
Xchar *str = *junkptr,*cut;
X 
X	if ((cut = strrchr(str,'.')) && cut != str)
X		{
X		*junkptr = strdup(cut+1);  /* .xx or xx? */
X		return 1;
X		}
X	return 0;
X}
X 
Xint remlpaths(junkptr) /**/
Xchar **junkptr;
X{
Xchar *str = *junkptr,*cut;
X 
X	if (cut = strrchr(str,'/'))
X		{
X		*cut = '\0';
X		*junkptr = strdup(cut+1);
X		return 1;
X		}
X	return 0;
X}
X
Xint makeuppercase(junkptr) /**/
Xchar **junkptr;
X{
Xchar *str = *junkptr;
X
X	for (; *str; str++)
X		*str = tuupper(*str);
X	return 1;
X}
X
Xint makelowercase(junkptr) /**/
Xchar **junkptr;
X{
Xchar *str = *junkptr;
X
X	for (; *str; str++)
X		*str = tulower(*str);
X	return 1;
X}
X
Xvoid subst(strptr,in,out,gbal) /**/
Xchar **strptr;char *in;char *out;int gbal;
X{
Xchar *str = *strptr,*cut,*sptr;
Xint off;
X
X	while (cut = (char *) ztrstr(str,in)) {
X		*cut = '\0';
X		cut += strlen(in);
X		off = cut-*strptr;
X		*strptr = tricat(*strptr,sptr = convamps(out,in),cut);
X		if (gbal) {
X			str = (char *) *strptr+off+strlen(sptr);
X			continue;
X		}
X		break;
X	}
X}
X 
Xchar *convamps(out,in) /**/
Xchar *out;char *in;
X{
Xchar *ptr,*ret,*pp;
Xint slen,inlen = strlen(in);
X 
X	for (ptr = out, slen = 0; *ptr; ptr++,slen++)
X		if (*ptr == '\\')
X			ptr++;
X		else if (*ptr == '&')
X			slen += inlen-1;
X	ret = pp = alloc(slen+1);
X	for (ptr = out; *ptr; ptr++)
X		if (*ptr == '\\')
X			*pp++ = *++ptr;
X		else if (*ptr == '&')
X			{
X			strcpy(pp,in);
X			pp += inlen;
X			}
X		else
X			*pp++ = *ptr;
X	*pp = '\0';
X	return ret;
X}
X
Xchar *makehstr(s) /**/
Xchar *s;
X{
Xchar *t;
X
X	t = s = strdup(s);
X	for (; *t; t++)
X		if (*t == HISTSPACE)
X			*t = ' ';
X	return s;
X}
X
Xchar *quietgetevent(ev) /**/
Xint ev;
X{
XLknode node;
X 
X	ev -= (lithist) ? firstlithist : firsthist;
X	if (ev < 0)
X		return NULL;
X	for (node = firstnode((lithist) ? lithistlist : histlist);
X			ev && node; incnode(node), ev--);
X	if (!node)
X		return NULL;
X	return getdata(node);
X}
X
Xchar *getevent(ev) /**/
Xint ev;
X{
XLknode node;
Xint oev = ev;
X 
X	ev -= firsthist;
X	for (node = firstnode(histlist); ev && node; incnode(node), ev--);
X	if (!node)
X		{
X		herrflush();
X		zerr("no such event: %d",NULL,oev);
X		return NULL;
X		}
X	return getdata(node);
X}
X 
Xint getargc(list) /**/
Xchar *list;
X{
Xint argc = 0;
X
X	for (; *list; list++)
X		if (*list == HISTSPACE)
X			argc++;
X	return argc;
X}
X 
Xchar *getargs(elist,arg1,arg2) /**/
Xchar *elist;int arg1;int arg2;
X{
Xchar *ret = elist,*retn;
Xint acnt = arg2-arg1+1;
X
X	while (arg1--)
X		while (*ret && *ret++ != HISTSPACE);
X	if (!*ret)
X		{
X		herrflush();
X		zerr("no such word in event",NULL,0);
X		return NULL;
X		}
X	retn = ret = strdup(ret);
X	while (acnt > 0)
X		{
X		while (*ret && *ret != HISTSPACE)
X			ret++;
X		if (*ret == HISTSPACE)
X			*ret = ' ';
X		else
X			break;
X		acnt--;
X		}
X	if (acnt > 1 && !*ret)
X		{
X		herrflush();
X		zerr("no such word in event",NULL,0);
X		return NULL;
X		}
X	*ret = '\0';
X	return retn;
X}
X
Xvoid upcase(x) /**/
Xchar **x;
X{
Xchar *pp = *(char **) x;
X
X	for (; *pp; pp++)
X		*pp = tuupper(*pp);
X}
X
Xvoid downcase(x) /**/
Xchar **x;
X{
Xchar *pp = *(char **) x;
X
X	for (; *pp; pp++)
X		*pp = tulower(*pp);
X}
X
Xint quote(tr) /**/
Xchar **tr;
X{
Xchar *ptr,*rptr,**str = (char **) tr;
Xint len = 1;
X 
X	for (ptr = *str; *ptr; ptr++,len++)
X		if (*ptr == '\'')
X			len += 3;
X	ptr = *str;
X	*str = rptr = zalloc(len);
X	for (ptr = *str; *ptr; )
X		if (*ptr == '\'')
X			{
X			*rptr++ = '\''; *rptr++ = '\\'; *rptr++ = '\''; *rptr++ = '\'';
X			ptr++;
X			}
X		else
X			*rptr++ = *ptr++;
X	return 0;
X}
X 
Xint quotebreak(tr) /**/
Xchar **tr;
X{
Xchar *ptr,*rptr,**str = (char **) tr;
Xint len = 1;
X 
X	for (ptr = *str; *ptr; ptr++,len++)
X		if (*ptr == '\'')
X			len += 3;
X		else if (inblank(*ptr))
X			len += 2;
X	ptr = *str;
X	*str = rptr = zalloc(len);
X	for (ptr = *str; *ptr; )
X		if (*ptr == '\'')
X			{
X			*rptr++ = '\''; *rptr++ = '\\'; *rptr++ = '\''; *rptr++ = '\'';
X			ptr++;
X			}
X		else if (inblank(*ptr))
X			{
X			*rptr++ = '\''; *rptr++ = *ptr++; *rptr++ = '\'';
X			}
X		else
X			*rptr++ = *ptr++;
X	return 0;
X}
X
Xstatic char *bp;
Xstatic int lensb,countp;
X
Xvoid stradd(d) /**/
Xchar *d;
X{
X	while (*bp++ = *d++);
X	bp--;
X}
X
Xint putstr(d) /**/
Xint d;
X{
X	*bp++ = d;
X	if (countp)
X		lensb++;
X	return 0;
X}
X
X#define tstradd(X) \
X	if (termok && unset(SINGLELINEZLE)) { \
X		char tbuf[2048],*tptr = tbuf; \
X		if (tgetstr(X,&tptr)) \
X			tputs(tbuf,1,putstr); \
X	} \
X	break
X
X/* get a prompt string */
X
Xchar *putprompt(fm,lenp) /**/
Xchar *fm;int *lenp;
X{
Xchar *ss,*ttyname DCLPROTO((int)),*bl0;
Xstatic char buf1[256],buf2[256],*buf;
Xchar buf3[MAXPATHLEN];
Xint t0,bracepos = 0;
Xstruct tm *tm = NULL;
Xtime_t timet;
X
X	lensb = 0; countp = 1;
X	if (!fm)
X		{
X		*lenp = 0;
X		return "";
X		}
X	/* kludge alert! */
X	buf = (buf == buf1) ? buf2 : buf1;
X	bp = bl0 = buf;
X	if (!columns)
X		columns = 80;
X	clearerr(stdin);
X	for(;*fm;fm++)
X		{
X		if (bp-buf >= 220)
X			break;
X		if (*fm == '%')
X			switch (*++fm)
X				{
X				case '~':
X					t0 = finddir(cwd);
X					if (t0 != -1) {
X						*bp++ = '~';
X						stradd(usernames[t0]);
X						stradd(cwd+strlen(userdirs[t0]));
X						break;
X					}
X					if (!strncmp(cwd,home,t0 = strlen(home)) && t0 > 1) {
X						*bp++ = '~';
X						stradd(cwd+t0);
X						break;
X					}
X				case 'd': case '/': stradd(cwd); break;
X				case 'c': case '.':
X					t0 = finddir(cwd);
X					if (t0 != -1) {
X						sprintf(buf3,"~%s%s",usernames[t0],
X							cwd+strlen(userdirs[t0]));
X					} else if (!strncmp(cwd,home,t0 = strlen(home)) && t0 > 1) {
X						sprintf(buf3,"~%s",cwd+t0);
X					} else {
X						strcpy(buf3,cwd);
X					}
X					t0 = 1;
X					if (idigit(fm[1])) { t0 = fm[1]-'0'; fm++; }
X					for (ss = buf3+strlen(buf3); ss > buf3; ss--)
X						if (*ss == '/' && !--t0) {
X							ss++;
X							break;
X						}
X					if (*ss == '/' && ss[1]) ss++;
X					stradd(ss);
X					break;
X				case 'C':
X					strcpy(buf3,cwd);
X					t0 = 1;
X					if (idigit(fm[1])) { t0 = fm[1]-'0'; fm++; }
X					for (ss = buf3+strlen(buf3); ss > buf3; ss--)
X						if (*ss == '/' && !--t0) {
X							ss++;
X							break;
X						}
X					if (*ss == '/' && ss[1]) ss++;
X					stradd(ss);
X					break;
X				case 'h': case '!':
X					sprintf(bp,"%d",curhist);
X					bp += strlen(bp);
X					break;
X				case 'M': stradd(hostnam); break;
X				case 'm':
X					if (idigit(fm[1]))
X						t0 = (*++fm)-'0';
X					else
X						t0 = 1;
X					for (ss = hostnam; *ss; ss++)
X						if (*ss == '.' && !--t0)
X							break;
X					t0 = *ss;
X					*ss = '\0';
X					stradd(hostnam);
X					*ss = t0;
X					break;
X				case 'S': tstradd("so"); /* <- this is a macro */
X				case 's': tstradd("se");
X				case 'B': tstradd("md");
X				case 'b': tstradd("me");
X				case 'U': tstradd("us");
X				case 'u': tstradd("ue");
X				case '{': bracepos = bp-buf; countp = 0; break;
X				case '}': lensb += (bp-buf)-bracepos; countp = 1; break;
X				case 't': case '@':
X					timet = time(NULL);
X					tm = localtime(&timet);
X					ztrftime(bp,16,"%l:%M%p",tm);
X					if (*bp == ' ')
X						chuck(bp);
X					bp += strlen(bp);
X					break;
X				case 'T':
X					timet = time(NULL);
X					tm = localtime(&timet);
X					ztrftime(bp,16,"%k:%M",tm);
X					bp += strlen(bp);
X					break;
X				case '*':
X					timet = time(NULL);
X					tm = localtime(&timet);
X					ztrftime(bp,16,"%k:%M:%S",tm);
X					bp += strlen(bp);
X					break;
X				case 'n': stradd(username); break;
X				case 'w':
X					timet = time(NULL);
X					tm = localtime(&timet);
X					ztrftime(bp,16,"%a %e",tm);
X					bp += strlen(bp);
X					break;
X				case 'W':
X					timet = time(NULL);
X					tm = localtime(&timet);
X					ztrftime(bp,16,"%m/%d/%y",tm);
X					bp += strlen(bp);
X					break;
X				case 'D':
X					timet = time(NULL);
X					tm = localtime(&timet);
X					ztrftime(bp,16,"%y-%m-%d",tm);
X					bp += strlen(bp);
X					break;
X				case 'l':
X					if (ss = ttyname(SHTTY))
X						stradd((strncmp(ss,"/dev/tty",8) ? ss : ss+8));
X					else
X						stradd("()");
X					break;
X				case '?':
X					sprintf(bp,"%d",lastval);
X					bp += strlen(bp);
X					break;
X				case '%': *bp++ = '%'; break;
X				case '#': *bp++ = (geteuid()) ? '%' : '#'; break;
X				default: *bp++ = '%'; *bp++ = *fm; break;
X				}
X		else if (*fm == '!')
X			{
X			sprintf(bp,"%d",curhist);
X			bp += strlen(bp);
X			}
X		else
X			{
X			if (fm[0] == '\\' && fm[1])
X				fm++;
X			if ((*bp++ = *fm) == '\n')
X				bl0 = bp;
X			}
X		}
X	*lenp = (bp-bl0)-lensb;
X	*lenp %= columns;
X	if (*lenp == columns-1)
X		{
X		*lenp = 0;
X		*bp++ = ' ';
X		}
X	*bp = '\0';
X	return buf;
X}
X
Xvoid herrflush() /**/
X{
X	if (strin)
X		hflush();
X	else while (lastc != '\n' && !lexstop)
X		hgetch();
X}
X
X/* read an arbitrary amount of data into a buffer until stop is found */
X
Xchar *hdynread(stop) /**/
Xint stop;
X{
Xint bsiz = 256,ct = 0,c;
Xchar *buf = zalloc(bsiz),*ptr;
X 
X	ptr = buf;
X	while ((c = hgetch()) != stop && c != '\n' && !lexstop)
X		{
X		if (c == '\\')
X			c = hgetch();
X		*ptr++ = c;
X		if (++ct == bsiz)
X			{
X			buf = realloc(buf,bsiz *= 2);
X			ptr = buf+ct;
X			}
X		}
X	*ptr = 0;
X	if (c == '\n')
X		{
X		hungetch('\n');
X		zerr("delimiter expected",NULL,0);
X		free(buf);
X		return NULL;
X		}
X	return buf;
X}
X 
Xchar *hdynread2(stop) /**/
Xint stop;
X{
Xint bsiz = 256,ct = 0,c;
Xchar *buf = zalloc(bsiz),*ptr;
X 
X	ptr = buf;
X	while ((c = hgetch()) != stop && c != '\n' && !lexstop)
X		{
X		if (c == '\n')
X			{
X			hungetch(c);
X			break;
X			}
X		if (c == '\\')
X			c = hgetch();
X		*ptr++ = c;
X		if (++ct == bsiz)
X			{
X			buf = realloc(buf,bsiz *= 2);
X			ptr = buf+ct;
X			}
X		}
X	*ptr = 0;
X	if (c == '\n')
X		hungetch('\n');
X	return buf;
X}
X
X/* set cbreak mode, or the equivalent */
X
Xvoid setcbreak() /**/
X{
Xstruct ttyinfo ti;
X
X	ti = shttyinfo;
X#ifdef TERMIOS
X	ti.termios.c_lflag &= ~ICANON;
X	ti.termios.c_cc[VMIN] = 1;
X	ti.termios.c_cc[VTIME] = 0;
X#else
X#ifdef TERMIO
X	ti.termio.c_lflag &= ~ICANON;
X	ti.termio.c_cc[VMIN] = 1;
X	ti.termio.c_cc[VTIME] = 0;
X#else
X	ti.sgttyb.sg_flags |= CBREAK;
X#endif
X#endif
X	settyinfo(&ti);
X}
X
Xint getlineleng() /**/
X{
Xint z;
X
X#ifdef TIOCSWINSZ
X	z = shttyinfo.winsize.ws_col;
X	return (z) ? z : 80;
X#else
X	return 80;
X#endif
X}
X
Xvoid unsetcbreak() /**/
X{
X	settyinfo(&shttyinfo);
X}
X
X/* give the tty to some process */
X
Xvoid attachtty(pgrp) /**/
Xlong pgrp;
X{
Xstatic int ep = 0;
Xint arg = pgrp;
X
X	if (jobbing)
X#ifndef TIOCSPGRP
X		if (SHTTY != -1 && tcsetpgrp(SHTTY,pgrp) == -1 && !ep)
X#else
X		if (SHTTY != -1 && ioctl(SHTTY,TIOCSPGRP,&arg) == -1 && !ep)
X#endif
X			{
X			zerr("can't set tty pgrp: %e",NULL,errno);
X			fflush(stderr);
X			opts[MONITOR] = OPT_UNSET;
X			ep =1;
X			errflag = 0;
X			}
X}
X
SHAR_EOF
chmod 0644 zsh2.1/src/hist.c ||
echo 'restore of zsh2.1/src/hist.c failed'
Wc_c="`wc -c < 'zsh2.1/src/hist.c'`"
test 24813 -eq "$Wc_c" ||
	echo 'zsh2.1/src/hist.c: original size 24813, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.1/src/init.c ==============
if test -f 'zsh2.1/src/init.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.1/src/init.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.1/src/init.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.1/src/init.c' &&
X/*
X
X	init.c - main loop and initialization routines
X
X	This file is part of zsh, the Z shell.
X
X	zsh is free software; no one can prevent you from reading the source
X   code, or giving it to someone else.
X
X   This file is copyrighted under the GNU General Public License, which
X   can be found in the file called COPYING.
X
X   Copyright (C) 1990, 1991 Paul Falstad
X
X   zsh is distributed in the hope that it will be useful, but
X   WITHOUT ANY WARRANTY.  No author or distributor accepts
X   responsibility to anyone for the consequences of using it or for
X   whether it serves any particular purpose or works at all, unless he
X   says so in writing.  Refer to the GNU General Public License
X   for full details.
X
X   Everyone is granted permission to copy, modify and redistribute
X   zsh, but only under the conditions described in the GNU General Public
X   License.   A copy of this license is supposed to have been given to you
X   along with zsh so you can know your rights and responsibilities.
X   It should be in a file named COPYING.
X
X   Among other things, the copyright notice and this notice must be
X   preserved on all copies.
X
X*/
X
X#define GLOBALS
X#include "zsh.h"
X#include <pwd.h>
X
Xextern int yydebug;
X
Xvoid main(argc,argv,envp) /**/
Xint argc; char **argv; char **envp;
X{
Xint notect = 0;
X
X	environ = envp;
X	pathsuppress = 1;
X	meminit();
X	setflags();
X	parseargs(argv);
X	setmoreflags();
X	setupvals();
X	initialize();
X	heapalloc();
X	runscripts();
X	if (interact)
X		{
X		pathsuppress = 0;
X		newcmdnamtab();
X		}
X	for(;;)
X		{
X		do
X			loop();
X		while (tok != ENDINPUT);
X		if (!(isset(IGNOREEOF) && interact))
X			{
X#if 0
X			if (interact)
X				fputs(islogin ? "logout\n" : "exit\n",stderr);
X#endif
X			zexit(NULL);
X			continue;
X			}
X		zerrnam("zsh",(!islogin) ? "use 'exit' to exit."
X			: "use 'logout' to logout.",NULL,0);
X		notect++;
X		if (notect == 10)
X			zexit(NULL);
X		}
X}
X
X/* keep executing lists until EOF found */
X
Xvoid loop() /**/
X{
XList list;
X
X	pushheap();
X	for(;;)
X		{
X		freeheap();
X		if (interact && isset(SHINSTDIN))
X			preprompt();
X		hbegin();		/* init history mech */
X		intr();			/* interrupts on */
X		ainit();			/* init alias mech */
X		lexinit();
X		errflag = 0;
X		if (!(list = parse_event()))
X			{				/* if we couldn't parse a list */
X			hend();
X			if (tok == ENDINPUT && !errflag)
X				break;
X			continue;
X			}
X		if (hend())
X			{
X			if (stopmsg)		/* unset 'you have stopped jobs' flag */
X				stopmsg--;
X			execlist(list);
X			}
X		if (ferror(stderr))
X			{
X			zerr("write error",NULL,0);
X			clearerr(stderr);
X			}
X		if (subsh)				/* how'd we get this far in a subshell? */
X			exit(lastval);
X		if ((!interact && errflag) || retflag)
X			break;
X		if ((opts['t'] == OPT_SET) || (lastval && opts[ERREXIT] == OPT_SET))
X			{
X			if (sigtrapped[SIGEXIT])
X				dotrap(SIGEXIT);
X			exit(lastval);
X			}
X		}
X	popheap();
X}
X
Xvoid setflags() /**/
X{
Xint c;
X
X	for (c = 0; c != 32; c++)
X		opts[c] = OPT_UNSET;
X	for (c = 32; c != 128; c++)
X		opts[c] = OPT_INVALID;
X	for (c = 'a'; c <= 'z'; c++)
X		opts[c] = opts[c-'a'+'A'] = OPT_UNSET;
X	for (c = '0'; c <= '9'; c++)
X		opts[c] = OPT_UNSET;
X	opts['A'] = OPT_INVALID;
X	opts['i'] = (isatty(0)) ? OPT_SET : OPT_UNSET;
X	opts[BGNICE] = opts[NOTIFY] = OPT_SET;
X	opts[USEZLE] = (interact && SHTTY != -1) ? OPT_SET : OPT_UNSET;
X}
X
Xstatic char *cmd;
X
Xvoid parseargs(argv) /**/
Xchar **argv;
X{
Xchar **x;
Xint bk = 0,action;
XLklist paramlist;
X
X	hackzero = argzero = *argv;
X	opts[LOGINSHELL] = (**(argv++) == '-') ? OPT_SET : OPT_UNSET;
X	SHIN = 0;
X	while (!bk && *argv && (**argv == '-' || **argv == '+'))
X		{
X		action = (**argv == '-') ? OPT_SET : OPT_UNSET;
X		while (*++*argv)
X			{
X			if (opts[**argv] == OPT_INVALID)
X				{
X				zerr("bad option: -%c",NULL,**argv);
X				exit(1);
X				}
X			opts[**argv] = action;
X			if (bk = **argv == 'b')
X				break;
X			if (**argv == 'c') /* -c command */
X				{
X				argv++;
X				if (!*argv)
X					{
X					zerr("string expected after -c",NULL,0);
X					exit(1);
X					}
X				cmd = *argv;
X				opts[INTERACTIVE] = OPT_UNSET;
X				break;
X				}
X			else if (**argv == 'o')
X				{
X				int c;
X
X				if (!*++*argv)
X					argv++;
X				if (!*argv)
X					{
X					zerr("string expected after -o",NULL,0);
X					exit(1);
X					}
X				c = optlookup(*argv);
X				if (c == -1)
X					zerr("no such option: %s",*argv,0);
X				else
X					opts[c] = action;
X				break;
X				}
X			}
X		argv++;
X		}
X	paramlist = newlist();
X	if (*argv)
X		{
X		if (opts[SHINSTDIN] == OPT_UNSET)
X			{
X			SHIN = movefd(open(argzero = *argv,O_RDONLY));
X			if (SHIN == -1)
X				{
X				zerr("can't open input file: %s",*argv,0);
X				exit(1);
X				}
X			opts[INTERACTIVE] = OPT_UNSET;
X			argv++;
X			}
X		while (*argv)
X			addnode(paramlist,ztrdup(*argv++));
X		}
X	else
X		opts[SHINSTDIN] = OPT_SET;
X	pparams = x = zcalloc((countnodes(paramlist)+1)*sizeof(char *));
X	while (*x++ = getnode(paramlist));
X	free(paramlist);
X	argzero = ztrdup(argzero);
X}
X
Xvoid setmoreflags() /**/
X{
Xint t0;
X
X	/* stdout,stderr fully buffered */
X#ifdef _IOFBF
X	setvbuf(stdout,malloc(BUFSIZ),_IOFBF,BUFSIZ);
X	setvbuf(stderr,malloc(BUFSIZ),_IOFBF,BUFSIZ);
X#else
X	setbuffer(stdout,malloc(BUFSIZ),BUFSIZ);
X	setbuffer(stderr,malloc(BUFSIZ),BUFSIZ);
X#endif
X	subsh = 0;
X#ifndef NOCLOSEFUNNYFDS
X	/* this works around a bug in some versions of in.rshd */
X	for (t0 = 3; t0 != 10; t0++)
X		close(t0);
X#endif
X#ifdef JOB_CONTROL
X	opts[MONITOR] = (interact) ? OPT_SET : OPT_UNSET;
X	if (jobbing)
X		{
X		SHTTY = movefd((isatty(0)) ? dup(0) : open("/dev/tty",O_RDWR));
X		if (SHTTY == -1)
X			opts[MONITOR] = OPT_UNSET;
X		else
X			{
X#ifdef TIOCSETD
X			int ldisc = NTTYDISC;
X			ioctl(SHTTY, TIOCSETD, &ldisc);
X#endif
X			gettyinfo(&shttyinfo);	/* get tty state */
X			savedttyinfo = shttyinfo;
X			}
X#ifdef sgi
X		setpgrp(0,getpgrp(0));
X#endif
X		if ((mypgrp = getpgrp(0)) <= 0)
X			opts[MONITOR] = OPT_UNSET;
X		}
X	else
X		SHTTY = -1;
X#else
X	opts[MONITOR] = OPT_UNSET;
X	SHTTY = movefd((isatty(0)) ? dup(0) : open("/dev/tty",O_RDWR));
X	if (SHTTY != -1)
X		{
X		gettyinfo(&shttyinfo);
X		savedttyinfo = shttyinfo;
X		}
X#endif
X}
X
Xvoid setupvals() /**/
X{
Xstruct passwd *pwd;
Xchar *ptr;
Xstatic long bauds[] = {
X	0,50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,19200,38400
X	};
X
X	curhist = 0;
X	histsiz = 20;
X	lithistsiz = 5;
X	logcheck = 60;
X	dirstacksize = -1;
X	listmax = 100;
X	bangchar = '!';
X	hashchar = '#';
X	hatchar = '^';
X	termok = 0;
X	curjob = prevjob = coprocin = coprocout = -1;
X	shtimer = time(NULL);	/* init $SECONDS */
X	srand((unsigned int) shtimer);
X	/* build various hash tables; argument to newhtable is table size */
X	aliastab = newhtable(37);
X	addreswords();
X	paramtab = newhtable(151);
X	cmdnamtab = newhtable(13);
X	initxbindtab();
X	nullcmd = ztrdup("cat");
X	prompt = ztrdup("%m%# ");
X	prompt2 = ztrdup("> ");
X	prompt3 = ztrdup("?# ");
X	prompt4 = ztrdup("+ ");
X	sprompt = ztrdup("zsh: correct `%s' to `%r' [nyae]? ");
X	ppid = getppid();
X#ifdef TERMIOS
X	baud = bauds[shttyinfo.termios.c_cflag & CBAUD];
X#else
X#ifdef TERMIO
X	baud = bauds[shttyinfo.termio.c_cflag & CBAUD];
X#else
X	baud = bauds[shttyinfo.sgttyb.sg_ospeed];
X#endif
X#endif
X#ifdef TIOCGWINSZ
X	if (!(columns = shttyinfo.winsize.ws_col))
X		columns = 80;
X	if (!(lines = shttyinfo.winsize.ws_row))
X		lines = 24;
X#else
X	columns = 80;
X	lines = 24;
X#endif
X	ifs = ztrdup(" \t\n");
X	if (pwd = getpwuid(getuid())) {
X		username = ztrdup(pwd->pw_name);
X		home = ztrdup(pwd->pw_dir);
X	} else {
X		username = ztrdup("");
X		home = ztrdup("/");
X	}
X	timefmt = ztrdup(DEFTIMEFMT);
X	watchfmt = ztrdup(DEFWATCHFMT);
X	if (!(ttystrname = ztrdup(ttyname(SHTTY))))
X		ttystrname = ztrdup("");
X	wordchars = ztrdup(DEFWORDCHARS);
X	fceditparam = ztrdup(DEFFCEDIT);
X	tmpprefix = ztrdup(DEFTMPPREFIX);
X	if (ispwd(home))
X		cwd = ztrdup(home);
X	else if ((ptr = zgetenv("PWD")) && ispwd(ptr))
X		cwd = ztrdup(ptr);
X	else
X		cwd = zgetwd();
X	oldpwd = ztrdup(cwd);
X	hostnam = zalloc(256);
X	underscore = ztrdup("");
X	gethostname(hostnam,256);
X	mypid = getpid();
X	cdpath = mkarray(NULL);
X	fignore = mkarray(NULL);
X	fpath = mkarray(NULL);
X	mailpath = mkarray(NULL);
X	watch = mkarray(NULL);
X	hosts = mkarray(NULL);
X	hostcmds = (char **) zcalloc(sizeof(char *)*7);
X	hostcmds[0] = ztrdup("telnet"); hostcmds[1] = ztrdup("rlogin");
X	hostcmds[2] = ztrdup("ftp"); hostcmds[3] = ztrdup("rup");
X	hostcmds[4] = ztrdup("rusers"); hostcmds[5] = ztrdup("rsh");
X	optcmds = (char **) zcalloc(sizeof(char *)*3);
X	optcmds[0] = ztrdup("setopt"); optcmds[1] = ztrdup("unsetopt");
X	bindcmds = (char **) zcalloc(sizeof(char *)*2);
X	bindcmds[0] = ztrdup("bindkey");
X	varcmds = (char **) zcalloc(sizeof(char *)*5);
X	varcmds[0] = ztrdup("export"); varcmds[1] = ztrdup("typeset");
X	varcmds[2] = ztrdup("vared"); varcmds[3] = ztrdup("unset");
X	userdirs = (char **) zcalloc(sizeof(char *)*2);
X	usernames = (char **) zcalloc(sizeof(char *)*2);
X	userdirsz = 2;
X	userdirct = 0;
X	optarg = ztrdup("");
X	optind = 0;
X	schedcmds = NULL;
X	path = (char **) zalloc(4*sizeof *path);
X	path[0] = ztrdup("/bin"); path[1] = ztrdup("/usr/bin");
X	path[2] = ztrdup("/usr/ucb"); path[3] = NULL;
X	inittyptab();
X	initlextabs();
X	setupparams();
X	setparams();
X	inittyptab();
X}
X
Xvoid initialize() /**/
X{
Xint t0;
X
X	breaks = loops = 0;
X	lastmailcheck = time(NULL);
X	firsthist = firstlithist = 1;
X	histsiz = DEFAULT_HISTSIZE;
X	histlist = newlist();
X	lithistlist = newlist();
X	locallist = NULL;
X	dirstack = newlist();
X	bufstack = newlist();
X	newcmdnamtab();
X	inbuf = zalloc(inbufsz = 256);
X	inbufptr = inbuf+inbufsz;
X	inbufct = 0;
X#ifdef QDEBUG
X	signal(SIGQUIT,SIG_IGN);
X#endif
X#ifdef RLIM_INFINITY
X	for (t0 = 0; t0 != RLIM_NLIMITS; t0++)
X		getrlimit(t0,limits+t0);
X#endif
X	hsubl = hsubr = NULL;
X	lastpid = 0;
X	bshin = fdopen(SHIN,"r");
X	signal(SIGCHLD,handler);
X	if (jobbing)
X		{
X		signal(SIGTTOU,SIG_IGN);
X		signal(SIGTSTP,SIG_IGN);
X		signal(SIGTTIN,SIG_IGN);
X		signal(SIGPIPE,SIG_IGN);
X		attachtty(mypgrp);
X		}
X	if (interact)
X		{
X		signal(SIGTERM,SIG_IGN);
X#ifdef SIGWINCH
X		signal(SIGWINCH,handler);
X#endif
X		signal(SIGALRM,handler);
X		intr();
X		}
X}
X
Xvoid addreswords() /**/
X{
Xstatic char *reswds[] = {
X	"do", "done", "esac", "then", "elif", "else", "fi", "for", "case",
X	"if", "while", "function", "repeat", "time", "until", "exec", "command",
X	"select", "coproc", "noglob", "-", "nocorrect", "foreach", "end", NULL
X	};
Xint t0;
X
X	for (t0 = 0; reswds[t0]; t0++)
X		addhperm(reswds[t0],mkanode(NULL,-1-t0),aliastab,NULL);
X}
X
Xvoid runscripts() /**/
X{
X	if (opts[NORCS] == OPT_SET) {
X#ifdef GLOBALZPROFILE
X		source(GLOBALZPROFILE);
X#endif
X#ifdef GLOBALZSHRC
X		source(GLOBALZSHRC);
X#endif
X#ifdef GLOBALZLOGIN
X		if (islogin) source(GLOBALZLOGIN);
X#endif
X		return;
X	}
X	sourcehome(".zshenv");
X	if (opts[NORCS] == OPT_SET)
X		return;
X	if (interact) {
X		if (islogin) {
X			sourcehome(".zprofile");
X#ifdef GLOBALZPROFILE
X			source(GLOBALZPROFILE);
X#endif
X		}
X#ifdef GLOBALZSHRC
X		source(GLOBALZSHRC);
X#endif
X		sourcehome(".zshrc");
X		if (islogin) {
X#ifdef GLOBALZLOGIN
X			source(GLOBALZLOGIN);
X#endif
X			sourcehome(".zlogin");
X		}
X	}
X	if (interact)
X		readhistfile(getsparam("HISTFILE"),0);
X	if (opts['c'] == OPT_SET)
X		{
X		if (SHIN >= 10)
X			close(SHIN);
X		SHIN = movefd(open("/dev/null",O_RDONLY));
X		hungets(cmd);
X		strinbeg();
X		}
X#ifdef TIOCSWINSZ
X	if (!(columns = shttyinfo.winsize.ws_col))
X		columns = 80;
X	if (!(lines = shttyinfo.winsize.ws_row))
X		lines = 24;
X#endif
X}
X
Xvoid ainit() /**/
X{
X	alstackind = 0;		/* reset alias stack */
X	alstat = 0;
X	isfirstln = 1;
X}
X
Xvoid readhistfile(s,err) /**/
Xchar *s;int err;
X{
Xchar buf[1024];
XFILE *in;
X
X	if (!s)
X		return;
X	if (in = fopen(s,"r"))
X		{
X		permalloc();
X		while (fgets(buf,1024,in))
X			{
X			int l = strlen(buf);
X			char *pt = buf;
X
X			if (l && buf[l-1] == '\n')
X				buf[l-1] = '\0';
X			for (;*pt;pt++)
X			    if (*pt == ' ')
X				*pt = HISTSPACE;
X			addnode(histlist,ztrdup(buf));
X			addnode(lithistlist,ztrdup(buf));
X			curhist++;
X			}
X		fclose(in);
X		lastalloc();
X		}
X	else if (err)
X		zerr("can't read history file",s,0);
X}
X
Xvoid savehistfile(s,err) /**/
Xchar *s;int err;
X{
Xchar *t;
XLknode n;
XLklist l;
XFILE *out;
X
X	if (!s || !interact)
X		return;
X	if (out = fdopen(open(s,O_CREAT|O_WRONLY|O_TRUNC,0600),"w"))
X		{
X		n = lastnode(l = (isset(HISTLIT) ? lithistlist : histlist));
X		if (n == (Lknode) l)
X			{
X			fclose(out);
X			return;
X			}
X		while (--savehist && prevnode(n) != (Lknode) l)
X			n = prevnode(n);
X		for (; n; incnode(n))
X			{
X			for (s = t = getdata(n); *s; s++)
X				if (*s == HISTSPACE)
X					*s = ' ';
X			fputs(t,out);
X			fputc('\n',out);
X			}
X		fclose(out);
X		}
X	else if (err)
X		zerr("can't write history file: %s",s,0);
X}
X
SHAR_EOF
chmod 0644 zsh2.1/src/init.c ||
echo 'restore of zsh2.1/src/init.c failed'
Wc_c="`wc -c < 'zsh2.1/src/init.c'`"
test 12375 -eq "$Wc_c" ||
	echo 'zsh2.1/src/init.c: original size 12375, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.1/src/jobs.c ==============
if test -f 'zsh2.1/src/jobs.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.1/src/jobs.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.1/src/jobs.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.1/src/jobs.c' &&
X/*
X
X	jobs.c - job control
X
X	This file is part of zsh, the Z shell.
X
X	zsh is free software; no one can prevent you from reading the source
X   code, or giving it to someone else.
X
X   This file is copyrighted under the GNU General Public License, which
X   can be found in the file called COPYING.
X
X   Copyright (C) 1990, 1991 Paul Falstad
SHAR_EOF
true || echo 'restore of zsh2.1/src/jobs.c failed'
fi
echo 'End of zsh2.1.0 part 7'
echo 'File zsh2.1/src/jobs.c is continued in part 8'
echo 8 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
-- 
Kent Landfield                   INTERNET: kent@sparky.IMD.Sterling.COM
Sterling Software, IMD           UUCP:     uunet!sparky!kent
Phone:    (402) 291-8300         FAX:      (402) 291-4362
Please send comp.sources.misc-related mail to kent@uunet.uu.net.
