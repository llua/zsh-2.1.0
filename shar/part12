Path: funic!fuug!mcsun!uunet!sparky!kent
From: pfalstad@phoenix.Princeton.EDU (Paul Falstad)
Newsgroups: comp.sources.misc
Subject: v24i012:  zsh2.1 - The Z shell, Part12/19
Message-ID: <1991Oct26.014937.19512@sparky.imd.sterling.com>
Date: 26 Oct 91 01:49:37 GMT
References: <csm-v24i001=zsh2.1.140401@sparky.IMD.Sterling.COM>
Sender: kent@sparky.imd.sterling.com (Kent Landfield)
Followup-To: comp.sources.d
Organization: Sterling Software, IMD
Lines: 2232
Approved: kent@sparky.imd.sterling.com
X-Md4-Signature: 62f8a3ddeea292d7224a63ad5835cf67

Submitted-by: pfalstad@phoenix.Princeton.EDU (Paul Falstad)
Posting-number: Volume 24, Issue 12
Archive-name: zsh2.1/part12
Environment: BSD
Supersedes: zsh2.00: Volume 18, Issue 84-98

#!/bin/sh
# this is zshar.12 (part 12 of zsh2.1.0)
# do not concatenate these parts, unpack them in order with /bin/sh
# file zsh2.1/src/zle_main.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 12; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping zsh2.1/src/zle_main.c'
else
echo 'x - continuing file zsh2.1/src/zle_main.c'
sed 's/^X//' << 'SHAR_EOF' >> 'zsh2.1/src/zle_main.c' &&
X		FD_SET(0,&foofd);
X		if ((tv.tv_usec = cost*costmult) > 500000)
X			tv.tv_usec = 500000;
X		if (!kungetct
X#ifdef HAS_SELECT
X			&& !select(1,&foofd,NULL,NULL,&tv)
X#endif
X			)
X			refresh();
X		}
X	if (menucmp)
X		freemenu();
X	statusline = NULL;
X	trashzle();
X	alarm(0);
X	z = strlen(line);
X	line[z] = '\n';
X	line[z+1] = 0;
X	heapalloc();
X	if (curhistline)
X		free(curhistline);
X	if (eofsent)
X		{
X		free(line);
X		line = NULL;
X		}
X	zleactive = 0;
X	freeundo();
X	return line;
X}
X
Xint getkeycmd() /**/
X{
Xchar buf[10];
Xint t0,ret;
XKey ky;
X
X	t0 = 1;
X	cky = NULL;
X	if ((c = getkey(1)) == -1)
X		return -1;
X	if ((ret = bindtab[c]) == z_sequenceleadin)
X		{
X		buf[0] = (c) ? c : 0x80;
X		for (;;)
X			{
X			c = getkey(0);
X			buf[t0++] = (c) ? c : 0x80;
X			buf[t0] = '\0';
X			if (!(ky = (Key) gethnode(buf,xbindtab)))
X				return z_undefinedkey;
X			if (ky->func != z_sequenceleadin)
X				{
X				cky = ky;
X				ret = ky->func;
X				break;
X				}
X			}
X		}
X	if (ret == z_vidigitorbeginningofline)
X		ret = (lastcmd & ZLE_ARG) ? z_digitargument : z_beginningofline;
X	else if (ret == z_executenamedcmd)
X		ret = executenamedcommand();
X	else if (ret == z_executelastnamedcmd)
X		ret = lastnamed;
X	return ret;
X}
X
Xvoid sendstring() /**/
X{
Xchar buf[2];
X
X	buf[0] = c;
X	buf[1] = '\0';
X	if (!cky)
X		cky = (Key) gethnode(buf,xbindtab);
X	ungetkeys(cky->str,cky->len);
X}
X
XKey makefunckey(fun) /**/
Xint fun;
X{
XKey ky = zcalloc(sizeof *ky);
X
X	ky->func = fun;
X	return ky;
X}
X
X/* initialize the bindings */
X
Xvoid initxbindtab() /**/
X{
Xint t0,vi = 0;
Xchar buf[3],*s;
X
X	lastnamed = z_undefinedkey;
X	if (s = zgetenv("VISUAL"))
X		{
X		if (ztrstr(s,"vi"))
X			vi = 1;
X		}
X	else if ((s = zgetenv("EDITOR")) && ztrstr(s,"vi"))
X		vi = 1;
X	if (vi)
X		{
X		for (t0 = 0; t0 != 32; t0++)
X			mainbindtab[t0] = viinsbind[t0];
X		for (t0 = 32; t0 != 256; t0++)
X			mainbindtab[t0] = z_selfinsert;
X		mainbindtab[127] = z_backwarddeletechar;
X		}
X	else
X		{
X		for (t0 = 0; t0 != 128; t0++)
X			mainbindtab[t0] = emacsbind[t0];
X		for (t0 = 128; t0 != 256; t0++)
X			mainbindtab[t0] = z_selfinsert;
X		}
X	for (t0 = 0200; t0 != 0240; t0++)
X		mainbindtab[t0] = z_undefinedkey;
X	for (t0 = 0; t0 != 128; t0++)
X		altbindtab[t0] = vicmdbind[t0];
X	for (t0 = 128; t0 != 256; t0++)
X		altbindtab[t0] = emacsbind[t0];
X	bindtab = mainbindtab;
X	kungetbuf = zalloc(kungetsz = 32);
X	kungetct = 0;
X	xbindtab = newhtable(67);
X	addhperm("\33\133C",makefunckey(z_forwardchar),xbindtab,NULL);
X	addhperm("\33\133D",makefunckey(z_backwardchar),xbindtab,NULL);
X	addhperm("\33\133A",makefunckey(z_uplineorhistory),xbindtab,NULL);
X	addhperm("\33\133B",makefunckey(z_downlineorhistory),xbindtab,NULL);
X	addhperm("\30*",makefunckey(z_expandword),xbindtab,NULL);
X	addhperm("\30g",makefunckey(z_listexpand),xbindtab,NULL);
X	addhperm("\30G",makefunckey(z_listexpand),xbindtab,NULL);
X	addhperm("\30\16",makefunckey(z_infernexthistory),xbindtab,NULL);
X	addhperm("\30\13",makefunckey(z_killbuffer),xbindtab,NULL);
X	addhperm("\30\6",makefunckey(z_vifindnextchar),xbindtab,NULL);
X	addhperm("\30\17",makefunckey(z_overwritemode),xbindtab,NULL);
X	addhperm("\30\25",makefunckey(z_undo),xbindtab,NULL);
X	addhperm("\30\26",makefunckey(z_vicmdmode),xbindtab,NULL);
X	addhperm("\30\12",makefunckey(z_vijoin),xbindtab,NULL);
X	addhperm("\30\2",makefunckey(z_vimatchbracket),xbindtab,NULL);
X	addhperm("\30s",makefunckey(z_historyincrementalsearchforward),
X		xbindtab,NULL);
X	addhperm("\30r",makefunckey(z_historyincrementalsearchbackward),
X		xbindtab,NULL);
X	addhperm("\30u",makefunckey(z_undo),xbindtab,NULL);
X	addhperm("\30\30",makefunckey(z_exchangepointandmark),
X		xbindtab,NULL);
X	addhperm("run-help",mkanode(ztrdup("man"),1),aliastab,NULL);
X	addhperm("which-command",mkanode(ztrdup("whence"),1),aliastab,NULL);
X	strcpy(buf,"\33q");
X	if (!vi)
X		for (t0 = 128; t0 != 256; t0++)
X			if (emacsbind[t0] != z_undefinedkey) {
X				buf[1] = t0 & 0x7f;
X				addhnode(ztrdup(buf),makefunckey(emacsbind[t0]),xbindtab,NULL);
X			}
X	for (t0 = 0; t0 != 36; t0++)
X		vibuf[t0] = NULL;
X	for (t0 = 0; t0 != 26; t0++)
X		vimarkline[t0] = 0;
X	stackhist = stackcs = -1;
X	vichgbufsz = 0;
X	vichgbuf = NULL;
X}
X
Xchar *getkeystring(s,len) /**/
Xchar *s;int *len;
X{
Xstatic char buf[512];
Xchar *t = buf;
Xint x,first = 1,metanext = 0;
X
X	for (;*s;s++)
X		{
X		if (*s == '\\' && s[1])
X			switch(*++s)
X				{
X				case 'a': *t++ = '\07'; break;
X				case 'n': *t++ = '\n'; break;
X				case 'b': *t++ = '\010'; break;
X				case 't': *t++ = '\t'; break;
X				case 'v': *t++ = '\v'; break;
X				case 'f': *t++ = '\f'; break;
X				case 'r': *t++ = '\r'; break;
X				case 'e': *t++ = '\033'; break;
X				case 'M':
X					if (s[1] == '-')
X						s++;
X					metanext = 2;
X					break;
X				default:
X					if (idigit(*s))
X						{
X						for (x = 0; idigit(*s); s++)
X							x = x*8+(*s-'0');
X						s--;
X						*t++ = x;
X						}
X					else
X						*t++ = *s;
X					break;
X				}
X		else if (*s == '^')
X			if (*++s == '?')
X				*t++ = 0x7f;
X			else
X				*t++ = *s & 0x9f;
X		else
X			*t++ = *s;
X		if (metanext && !(--metanext))
X			{
X			t[-1] |= 0x80;
X			metanext = 0;
X			}
X		if (t > buf+500)
X			break;
X		first = 0;
X		}
X	*t = '\0';
X	*len = t-buf;
X	return buf;
X}
X
Xvoid printbind(s,len) /**/
Xchar *s;int len;
X{
Xint ch;
X
X	while (len--)
X		{
X		ch = (unsigned char) *s++;
X		if (ch & 0x80)
X			{
X			printf("\\M-");
X			ch &= 0x7f;
X			}
X		if (icntrl(ch))
X			switch(ch)
X				{
X				case 0x7f: printf("^?"); break;
X				default: printf("^%c",(ch|0x40)); break;
X				}
X		else
X			putchar(ch);
X		}
X}
X
Xvoid printbinding(str,k) /**/
Xchar *str;Key k;
X{
X	if (k->func == z_sequenceleadin)
X		return;
X	putchar('\"');
X	printbind(str,strlen(str));
X	printf("\"\t");
X	if (k->func == z_sendstring)
X		{
X		putchar('\"');
X		printbind(k->str,k->len);
X		printf("\"\n");
X		}
X	else
X		printf("%s\n",zlecmds[k->func].name);
X}
X
Xint bin_bindkey(name,argv,ops,junc) /**/
Xchar *name;char **argv;char *ops;int junc;
X{
Xint t0,len;
Xchar *s;
Xint func,*tab;
X
X	tab = (ops['a']) ? altbindtab : mainbindtab;
X	if (ops['v'] || ops['e'] || ops['d'])
X		{
X		if (*argv)
X			{
X			zerrnam(name,"too many arguments",NULL,0);
X			return 1;
X			}
X		if (ops['d'] || ops['e'])
X			if (ops['m'])
X				for (t0 = 0; t0 != 256; t0++)
X					tab[t0] = emacsbind[t0];
X			else
X				{
X				for (t0 = 0; t0 != 128; t0++)
X					tab[t0] = emacsbind[t0];
X				for (t0 = 128; t0 != 256; t0++)
X					tab[t0] = z_selfinsert;
X				}
X		else
X			{
X			for (t0 = 0; t0 != 32; t0++)
X				mainbindtab[t0] = viinsbind[t0];
X			for (t0 = 32; t0 != 256; t0++)
X				mainbindtab[t0] = z_selfinsert;
X			mainbindtab[127] = z_backwarddeletechar;
X			}
X		for (t0 = 0; t0 != 128; t0++)
X			altbindtab[t0] = vicmdbind[t0];
X		for (t0 = 128; t0 != 256; t0++)
X			altbindtab[t0] = emacsbind[t0];
X		for (t0 = 0200; t0 != 0240; t0++)
X			tab[t0] = z_undefinedkey;
X		return 0;
X		}
X	if (!*argv)
X		{
X		char buf[2];
X		
X		buf[0] = 'x'; buf[1] = '\0';
X		for (t0 = 0; t0 != 256; t0++)
X			{
X			buf[0] = t0;
X			putchar('\"');
X			printbind(buf,1);
X			if (t0 < 254 && tab[t0] == tab[t0+1] && tab[t0] == tab[t0+2])
X				{
X				printf("\" to \"");
X				while (tab[t0] == tab[t0+1]) t0++;
X				buf[0] = t0;
X				printbind(buf,1);
X				}
X			printf("\"\t%s\n",zlecmds[tab[t0]].name);
X			}
X		listhtable(xbindtab,(HFunc) printbinding);
X		return 0;
X		}
X	while (*argv)
X		{
X		s = getkeystring(*argv++,&len);
X		if (len > 8)
X			{
X			zerrnam(name,"in-string too long",NULL,0);
X			return 1;
X			}
X		if (!*argv || ops['r'])
X			{
X			Key ky;
X
X			ky = gethnode(s,xbindtab);
X			if (len == 1)
X				func = tab[(unsigned char) *s];
X			else
X				func = (ky) ? ky->func : z_undefinedkey;
X			if (func == z_undefinedkey)
X				{
X				zerrnam(name,"in-string is not bound",NULL,0);
X				return 1;
X				}
X			if (ops['r'])
X				{
X				if (len == 1)
X					tab[(unsigned char) *s] = z_undefinedkey;
X				else
X					{
X					while (strlen(s) > 1)
X						{
X						free(remhnode(s,xbindtab));
X						s[strlen(s)-1] = '\0';
X						}
X					}
X				continue;
X				}
X			if (func == z_sendstring)
X				{
X				printbind(ky->str,ky->len);
X				putchar('\n');
X				return 0;
X				}
X			printf("%s\n",zlecmds[func].name);
X			return 0;
X			}
X		if (!ops['s'])
X			{
X			for (t0 = 0; t0 != ZLECMDCOUNT; t0++)
X				if (!strcmp(*argv,zlecmds[t0].name))
X					break;
X			if (t0 == ZLECMDCOUNT)
X				{
X				zerr("undefined function: %s",*argv,0);
X				return 1;
X				}
X			func = t0;
X			}
X		else
X			func = z_sendstring;
X		if (len == 1)
X			{
X			Key ky;
X
X			tab[(unsigned char) *s] = (ops['s']) ? z_sendstring : t0;
X			if (ops['s'])
X				{
X				addhnode(ztrdup(s),ky = makefunckey(z_sendstring),xbindtab,freekey);
X				ky->str = ztrdup(getkeystring(*argv,&ky->len));
X				}
X			}
X		else
X			{
X			int t1;
X			Key ky;
X
X			if (tab[(unsigned char) *s] != z_undefinedkey &&
X					tab[(unsigned char) *s] != z_sequenceleadin)
X				{
X				zerrnam(name,"in-string has already bound prefix",NULL,0);
X				return 1;
X				}
X			tab[(unsigned char) *s] = z_sequenceleadin;
X			if (!s[1])
X				s[1] = 0x80;
X			for (t1 = 1; t1 != len-1; t1++)
X				{
X				char sav;
X
X				sav = s[t1+1];
X				s[t1+1] = '\0';
X				ky = gethnode(s,xbindtab);
X				if (ky && ky->func != z_sequenceleadin)
X					{
X					zerrnam(name,"in-string has already bound prefix",NULL,0);
X					return 1;
X					}
X				if (!ky)
X					addhnode(ztrdup(s),makefunckey(z_sequenceleadin),xbindtab,
X						freekey);
X				if (!sav)
X					sav = 0x80;
X				s[t1+1] = sav;
X				}
X			addhnode(ztrdup(s),ky = makefunckey(func),xbindtab,freekey);
X			if (ops['s'])
X				ky->str = ztrdup(getkeystring(*argv,&ky->len));
X			}
X		argv++;
X		}
X	return 0;
X}
X
Xvoid freekey(x) /**/
Xvptr x;
X{
XKey k = x;
X
X	if (k->str)
X		free(k->str);
X	free(k);
X}
X
X/* this is mostly stolen from bash's draino() */
X
Xvoid drainoutput() /**/
X{
Xint n = 0;
X
X	if (!baud) return;
X#ifdef TIOCOUTQ
X#ifdef HAS_SELECT
X	while ((ioctl(SHTTY,TIOCOUTQ,&n) >= 0) && n) {
X		struct timeval tv;
X		tv.tv_sec = n/baud;
X		tv.tv_usec = ((n%baud)*1000000)/baud;
X		select (0,(fd_set *)0,(fd_set *)0,(fd_set *)0,&tv);
X	}
X#endif
X#endif
X}
X
SHAR_EOF
echo 'File zsh2.1/src/zle_main.c is complete' &&
chmod 0644 zsh2.1/src/zle_main.c ||
echo 'restore of zsh2.1/src/zle_main.c failed'
Wc_c="`wc -c < 'zsh2.1/src/zle_main.c'`"
test 14557 -eq "$Wc_c" ||
	echo 'zsh2.1/src/zle_main.c: original size 14557, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.1/src/zle_refresh.c ==============
if test -f 'zsh2.1/src/zle_refresh.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.1/src/zle_refresh.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.1/src/zle_refresh.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.1/src/zle_refresh.c' &&
X/*
X
X	zle_refresh.c - screen update
X
X	This file is part of zsh, the Z shell.
X
X	zsh is free software; no one can prevent you from reading the source
X   code, or giving it to someone else.
X
X   This file is copyrighted under the GNU General Public License, which
X   can be found in the file called COPYING.
X
X   Copyright (C) 1990, 1991 Paul Falstad
X
X   zsh is distributed in the hope that it will be useful, but
X   WITHOUT ANY WARRANTY.  No author or distributor accepts
X   responsibility to anyone for the consequences of using it or for
X   whether it serves any particular purpose or works at all, unless he
X   says so in writing.  Refer to the GNU General Public License
X   for full details.
X
X   Everyone is granted permission to copy, modify and redistribute
X   zsh, but only under the conditions described in the GNU General Public
X   License.   A copy of this license is supposed to have been given to you
X   along with zsh so you can know your rights and responsibilities.
X   It should be in a file named COPYING.
X
X   Among other things, the copyright notice and this notice must be
X   preserved on all copies.
X
X*/
X
X#define ZLE
X#include "zsh.h"
X
Xchar **obuf = NULL,**nbuf = NULL;
Xint olnct,nlnct;
Xint winw,winh,winpos;
X
Xint vcs,vln,vmaxln;
X
X#define nextline { *s = '\0'; \
X	if (winh == ln+1) if (nvln != -1) break; else ln = scrollwindow()-1; \
X	s = nbuf[++ln]; sen = s+winw; \
X	}
X
Xvoid resetvideo() /**/
X{
Xint ln;
Xstatic int lwinw = -1,lwinh = -1;
X
X	setterm();
X	winw = columns-1;
X	if (isset(SINGLELINEZLE) || !termok)
X		winh = 1;
X	else
X		winh = (lines < 2) ? 24 : lines;
X	winpos = vln = vmaxln = 0;
X	if (lwinw != winw || lwinh != winh)
X		{
X		if (nbuf)
X			{
X			for (ln = 0; ln != lwinh; ln++)
X				{
X				free(nbuf[ln]);
X				free(obuf[ln]);
X				}
X			free(nbuf);
X			free(obuf);
X			}
X		nbuf = (char **) zalloc((winh+1)*sizeof(char *));
X		obuf = (char **) zalloc((winh+1)*sizeof(char *));
X		for (ln = 0; ln != winh+1; ln++)
X			{
X			nbuf[ln] = zalloc(winw+1);
X			obuf[ln] = zalloc(winw+1);
X			}
X		lwinw = winw;
X		lwinh = winh;
X		}
X	for (ln = 0; ln != winh+1; ln++)
X		{
X		*nbuf[ln] = '\0';
X		*obuf[ln] = '\0';
X		}
X	if (!pptlen)
X		nbuf[0][0] = obuf[0][0] = '\0';
X	else
X		{
X		for (ln = 0; ln != pptlen-1; ln++)
X			nbuf[0][ln] = obuf[0][ln] = ' ';
X		nbuf[0][ln] = obuf[0][ln] = '>';
X		nbuf[0][pptlen] = obuf[0][pptlen] = '\0';
X		}
X	vcs = pptlen;
X	olnct = nlnct = 1;
X}
X
Xint scrollwindow() /**/
X{
Xint t0,hwinh = winh/2;
X
X	for (t0 = 0; t0 != winh-hwinh; t0++)
X		{
X		char *s;
X
X		s = nbuf[t0];
X		nbuf[t0] = nbuf[t0+hwinh];
X		nbuf[t0+hwinh] = s;
X		}
X	for (t0 = 0; t0 != pptlen-1; t0++)
X		nbuf[0][t0] = ' ';
X	strcpy(nbuf[0]+t0,"> ...");
X	return winh-hwinh;
X}
X
X/* this is the messy part. */
X
Xvoid refresh() /**/
X{
Xchar *s,*t,*sen,*scs = line+cs,**qbuf;
Xint ln = 0,nvcs,nvln = -1,t0;
X
X	cost = 0;
X	if (resetneeded)
X		{
X		resetvideo();
X		resetneeded = 0;
X		if (isset(SINGLELINEZLE) || !termok)
X			vcs = 0;
X		else
X			printf("%s",pmpt);
X		}
X	if (isset(SINGLELINEZLE) || !termok)
X		{
X		singlerefresh();
X		return;
X		}
X
X/* first, we generate the video line buffers so we know what to
X	put on the screen. 
X
X	s = ptr into the video buffer.
X	t = ptr into the real buffer.
X	sen = end of the video buffer (eol)
X*/
X
X	s = nbuf[ln = 0]+pptlen;
X	t = line;
X	sen = *nbuf+winw;
X	for (; *t; t++)
X		{
X		if (icntrl(*t))
X			if (*t == '\n')
X				{
X				if (t == scs)
X					{
X					nvcs = s-nbuf[nvln = ln];
X					scs = NULL;
X					}
X				nextline
X				}
X			else if (*t == '\t')
X				{
X				int t1 = s-nbuf[ln];
X
X				if ((t1|7)+1 >= winw) nextline
X				else
X					do
X						*s++ = ' ';
X					while ((++t1) & 7);
X				}
X			else
X				{
X				if (s == sen) nextline
X				*s++ = '^';
X				if (s == sen) nextline
X				*s++ = (*t == 127) ? '?' : (*t | '@');
X				}
X		else
X			{
X			if (s == sen) nextline
X			*s++ = *t;
X			}
X/* if the cursor is here, remember it */
X
X		if (t == scs)
X			nvcs = s-nbuf[nvln = ln]-1;
X		}
X	if (scs == t)
X		nvcs = s-nbuf[nvln = ln];
X	*s = '\0';
X	nlnct = ln+1;
X	if (statusline)
X		strcpy(nbuf[(nlnct == winh) ? winh-1 : nlnct++],statusline);
X
X/* do RPROMPT */
X
X	if (pmpt2 && ln == 0 && strlen(nbuf[0])+strlen(pmpt2) < winw)
X		{
X		for (t0 = strlen(nbuf[0]); t0 != winw; t0++)
X			nbuf[0][t0] = ' ';
X		strcpy(nbuf[0]+winw-strlen(pmpt2),pmpt2);
X		}
X	for (ln = 0; ln < nlnct; ln++)
X		{
X
X/* if old line and new line are different,
X	see if we can insert/delete a line */
X
X		if (ln < olnct && strncmp(nbuf[ln],obuf[ln],16))
X			{
X			if (tccan(TCDELLINE) && !strncmp(nbuf[ln],obuf[ln+1],16)
X					&& obuf[ln+1][0] && ln != olnct)
X				{
X				int t0;
X
X				moveto(ln,0);
X				tcout(TCDELLINE);
X				for (t0 = ln; t0 != olnct; t0++)
X					strcpy(obuf[t0],obuf[t0+1]);
X				olnct--;
X				}
X
X/* don't try to insert a line if olnct < vmaxln (vmaxln is the number
X	of lines that have been displayed by this routine) so that we don't
X	go off the end of the screen. */
X
X			else if (tccan(TCINSLINE) && !strncmp(nbuf[ln+1],obuf[ln],16) &&
X					olnct < vmaxln && nbuf[ln+1][0] && ln != olnct)
X				{
X				int t0;
X
X				moveto(ln,0);
X				tcout(TCINSLINE);
X				for (t0 = olnct; t0 != ln; t0--)
X					strcpy(obuf[t0],obuf[t0-1]);
X				*obuf[ln] = '\0';
X				olnct++;
X				}
X			}
X		refreshline(ln);
X		}
X
X/* if old buffer had extra lines, do a clear-end-of-display if we can,
X	otherwise, just fill new buffer with blank lines and refresh them */
X
X	if (olnct > nlnct)
X		{
X		for (ln = nlnct; ln < olnct; ln++)
X			nbuf[ln][0] = '\0';
X		if (tccan(TCCLEAREOD))
X			{
X			moveto(nlnct,0);
X			tcout(TCCLEAREOD);
X			}
X		else
X			for (ln = nlnct; ln < olnct; ln++)
X				refreshline(ln);
X		}
X
X/* move to the new cursor position */
X
X	moveto(nvln,nvcs);
X	qbuf = nbuf;
X	nbuf = obuf;
X	obuf = qbuf;
X	olnct = nlnct;
X	if (nlnct > vmaxln)
X		vmaxln = nlnct;
X	fflush(stdout);
X}
X
X#define tcinscost(X) (tccan(TCMULTINS) ? tclen[TCMULTINS] : (X)*tclen[TCINS])
X#define tcdelcost(X) (tccan(TCMULTDEL) ? tclen[TCMULTDEL] : (X)*tclen[TCDEL])
X#define tc_delchars(X) tcmultout(TCDEL,TCMULTDEL,(X))
X#define tc_inschars(X) tcmultout(TCINS,TCMULTINS,(X))
X#define tc_upcurs(X) tcmultout(TCUP,TCMULTUP,(X))
X#define tc_leftcurs(X) tcmultout(TCLEFT,TCMULTLEFT,(X))
X
Xvoid refreshline(ln) /**/
Xint ln;
X{
Xchar *nl = nbuf[ln],*ol = obuf[ln];
Xchar *p1;
Xint ccs = 0;
X
X	if (ln >= olnct)
X		*ol = '\0';
X	for (;;)
X		{
X		while (*nl && *nl == *ol)
X			{
X			nl++,ol++,ccs++;
X			}
X		if (!*nl && !*ol)
X			return;
X
X/* if this is the end of the new buffer but the old buffer has stuff
X	here, clear to end of line if we can, otherwise fill the new buffer
X	with blanks and continue. */
X
X		if (!*nl)
X			{
X			if (tccan(TCCLEAREOL) && strlen(ol) > tclen[TCCLEAREOL])
X				{
X				moveto(ln,ccs);
X				tcout(TCCLEAREOL);
X				*ol = '\0';
X				return;
X				}
X			else
X				{
X				int x = strlen(ol);
X				char *p = nl;
X
X				while (x--)
X					*p++ = ' ';
X				*p = '\0';
X				continue;
X				}
X			}
X
X/* if this is the end of the old buffer, just dump the rest of the
X	new buffer. */
X
X		if (!*ol)
X			{
X			while (*nl == ' ')
X				nl++,ccs++;
X			if (*nl)
X				{
X				moveto(ln,ccs);
X				fwrite(nl,strlen(nl),1,stdout);
X				cost += strlen(nl);
X				ccs = (vcs += strlen(nl));
X				}
X			return;
X			}
X		moveto(ln,ccs);
X
X/* try to insert/delete characters */
X
X		if (ol[1] != nl[1] && tccan(TCDEL))
X			{
X			int ct = 0;
X
X			for (p1 = ol; *p1; p1++,ct++)
X				if (tcdelcost(ct) < streqct(p1,nl))
X					{
X					tc_delchars(ct);
X					ol = p1;
X					break;
X					}
X			if (*p1)
X				continue;
X			}
X
X		if (ol[1] != nl[1] && tccan(TCINS))
X			{
X			int ct = 0;
X
X			for (p1 = nl; *p1; p1++,ct++)
X				if (tcinscost(ct) < streqct(p1,ol)+ct)
X					{
X/* make sure we aren't inserting characters off the end of the screen;
X	if we are, jump to the end and truncate the line, if we can do
X	it quickly */
X
X					if (ct+ccs+strlen(ol) >= winw-1)
X						{
X						if (!tccan(TCMULTRIGHT) || ccs > winw-tclen[TCMULTRIGHT])
X							continue;
X						moveto(ln,winw-1-ct);
X						if (!tccan(TCCLEAREOL) || ct < tclen[TCCLEAREOL])
X							{
X							int x = ct;
X
X							while (vcs++,x--)
X								putchar(' ');
X							}
X						else
X							tcout(TCCLEAREOL);
X						moveto(ln,ccs);
X						}
X					if (ct+ccs+strlen(ol) < winw-1)
X						{
X						tc_inschars(ct = p1-nl);
X						ccs = (vcs += p1-nl);
X						cost += ct;
X						fwrite(nl,ct,1,stdout);
X						nl += ct;
X						break;
X						}
X					}
X			if (*p1)
X				continue;
X			}
X
X/* if we can't do anything fancy, just write the new character and
X	keep going. */
X
X		putchar(*nl);
X		cost++;
X		nl++,ol++,ccs = ++vcs;
X		}
X}
X
Xvoid moveto(ln,cl) /**/
Xint ln;int cl;
X{
X
X/* move up */
X
X	if (ln < vln)
X		{
X		tc_upcurs(vln-ln);
X		vln = ln;
X		}
X
X/* move down; if we might go off the end of the screen, use newlines
X	instead of TCDOWN */
X
X	while (ln > vln)
X		if (cl < (vcs/2) || ln >= vmaxln || !tccan(TCLEFT))
X			{
X			putchar('\r');
X			putchar('\n');
X			cost+=2;
X			vln++;
X			vcs = 0;
X			}
X		else
X			{
X			tc_downcurs(ln-vln);
X			vln = ln;
X			}
X	if (cl < (vcs/2) || !tccan(TCLEFT))
X		{
X		putchar('\r');
X		cost++;
X		vcs = 0;
X		}
X	if (vcs < cl)
X		tc_rightcurs(cl-vcs);
X	else if (vcs > cl)
X		tc_leftcurs(vcs-cl);
X	vcs = cl;
X}
X
Xvoid tcmultout(cap,multcap,ct) /**/
Xint cap;int multcap;int ct;
X{
X	if (tccan(multcap) && (!tccan(cap) || tclen[multcap] < tclen[cap]*ct))
X		tcoutarg(multcap,ct);
X	else while (ct--)
X		tcout(cap);
X}
X
Xvoid tc_rightcurs(ct) /**/
Xint ct;
X{
X
X/* do a multright if it's cheaper or if we're walking over the prompt.  */
X
X	if (tccan(TCMULTRIGHT) &&
X			(ct > tclen[TCMULTRIGHT] || vln == 0 && vcs < pptlen))
X		tcoutarg(TCMULTRIGHT,ct);
X
X/* if we're walking over the prompt and we can do a bunch of cursor rights,
X	do them, even though they're more expensive.  (We can't redraw the
X	prompt very easily in general.)  */
X
X	else if (vln == 0 && vcs < pptlen && tccan(TCRIGHT))
X		while (ct--)
X			tcout(TCRIGHT);
X
X/* otherwise write the contents of the video buffer. */
X
X	else
X		fwrite(nbuf[vln]+vcs,ct,1,stdout);
X}
X
Xvoid tc_downcurs(ct) /**/
Xint ct;
X{
X	if (tccan(TCMULTDOWN) &&
X			(!tccan(TCDOWN) || tclen[TCMULTDOWN] < tclen[TCDOWN]*ct))
X		tcoutarg(TCMULTDOWN,ct);
X	else if (tccan(TCDOWN))
X		while (ct--)
X			tcout(TCDOWN);
X	else
X		{
X		while (ct--)
X			putchar('\n');
X		vcs = 0;
X		}
X}
X
X/* I'm NOT going to worry about padding unless anyone complains. */
X
Xvoid tcout(cap) /**/
Xint cap;
X{
X	tputs(tcstr[cap],1,putraw);
X}
X
Xvoid tcoutarg(cap,arg) /**/
Xint cap;int arg;
X{
X	tputs(tgoto(tcstr[cap],arg,arg),1,putraw);
X}
X
Xvoid clearscreen() /**/
X{
X	tcout(TCCLEARSCREEN);
X	resetneeded = 1;
X}
X
Xvoid redisplay() /**/
X{
X	trashzle();
X}
X
Xvoid trashzle() /**/
X{
X	if (zleactive)
X		{
X		refresh();
X		moveto(nlnct,0);
X		fflush(stdout);
X		unsetterm();
X		resetneeded = 1;
X		}
X}
X
Xvoid singlerefresh() /**/
X{
Xchar *vbuf,*vp,**qbuf,*op;
Xint t0,vsiz,nvcs;
X
X	for (vsiz = 1+pptlen, t0 = 0; t0 != ll; t0++,vsiz++)
X		if (line[t0] == '\t')
X			vsiz += 7;
X		else if (icntrl(line[t0]))
X			vsiz++;
X	vbuf = zalloc(vsiz);
X	strcpy(vbuf,pmpt);
X	vp = vbuf+pptlen;
X	for (t0 = 0; t0 != ll; t0++)
X		{
X		if (line[t0] == '\t')
X			do
X				*vp++ = ' ';
X			while ((vp-vbuf) & 7);
X		else if (line[t0] == '\n')
X			{
X			*vp++ = '\\';
X			*vp++ = 'n';
X			}
X		else if (line[t0] == 0x7f)
X			{
X			*vp++ = '^';
X			*vp++ = '?';
X			}
X		else if (icntrl(line[t0]))
X			{
X			*vp++ = '^';
X			*vp++ = line[t0] | '@';
X			}
X		else
X			*vp++ = line[t0];
X		if (t0 == cs)
X			nvcs = vp-vbuf-1;
X		}
X	if (t0 == cs)
X		nvcs = vp-vbuf;
X	*vp = '\0';
X	if ((winpos && nvcs < winpos+1) || (nvcs > winpos+winw-1))
X		{
X		if ((winpos = nvcs-(winw/2)) < 0)
X			winpos = 0;
X		}
X	if (winpos)
X		vbuf[winpos] = '<';
X	if (strlen(vbuf+winpos) > winw)
X		{
X		vbuf[winpos+winw-1] = '>';
X		vbuf[winpos+winw] = '\0';
X		}
X	strcpy(nbuf[0],vbuf+winpos);
X	free(vbuf);
X	nvcs -= winpos;
X	for (t0 = 0,vp = *nbuf,op = *obuf; *vp; t0++,vp++)
X		{
X		if (*vp != *op && !(*vp == ' ' && !*op))
X			{
X			singmoveto(t0);
X			putchar(*vp);
X			vcs++;
X			}
X		if (*op)
X			op++;
X		}
X	if (*op)
X		{
X		singmoveto(t0);
X		for (; *op; op++)
X			{
X			putchar(' ');
X			vcs++;
X			}
X		}
X	singmoveto(nvcs);
X	qbuf = nbuf;
X	nbuf = obuf;
X	obuf = qbuf;
X	fflush(stdout);
X}
X
Xvoid singmoveto(pos) /**/
Xint pos;
X{
X	while (pos < vcs)
X		{
X		vcs--;
X		putchar('\b');
X		}
X	while (pos > vcs)
X		{
X		putchar(nbuf[0][vcs]);
X		vcs++;
X		}
X}
X
Xint streqct(s,t) /**/
Xchar *s;char *t;
X{
Xint ct = 0;
X
X	while (*s && *s == *t) s++,t++,ct++;
X	return ct;
X}
X
SHAR_EOF
chmod 0644 zsh2.1/src/zle_refresh.c ||
echo 'restore of zsh2.1/src/zle_refresh.c failed'
Wc_c="`wc -c < 'zsh2.1/src/zle_refresh.c'`"
test 12102 -eq "$Wc_c" ||
	echo 'zsh2.1/src/zle_refresh.c: original size 12102, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.1/src/zle_utils.c ==============
if test -f 'zsh2.1/src/zle_utils.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.1/src/zle_utils.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.1/src/zle_utils.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.1/src/zle_utils.c' &&
X/*
X
X	zle_utils.c - miscellaneous line editor utilities
X
X	This file is part of zsh, the Z shell.
X
X	zsh is free software; no one can prevent you from reading the source
X   code, or giving it to someone else.
X
X   This file is copyrighted under the GNU General Public License, which
X   can be found in the file called COPYING.
X
X   Copyright (C) 1990, 1991 Paul Falstad
X
X   zsh is distributed in the hope that it will be useful, but
X   WITHOUT ANY WARRANTY.  No author or distributor accepts
X   responsibility to anyone for the consequences of using it or for
X   whether it serves any particular purpose or works at all, unless he
X   says so in writing.  Refer to the GNU General Public License
X   for full details.
X
X   Everyone is granted permission to copy, modify and redistribute
X   zsh, but only under the conditions described in the GNU General Public
X   License.   A copy of this license is supposed to have been given to you
X   along with zsh so you can know your rights and responsibilities.
X   It should be in a file named COPYING.
X
X   Among other things, the copyright notice and this notice must be
X   preserved on all copies.
X
X*/
X
X#define ZLE
X#include "zsh.h"
X
X/* make sure that the line buffer has at least sz chars */
X
Xvoid sizeline(sz) /**/
Xint sz;
X{
X	while (sz > linesz)
X		line = realloc(line,(linesz *= 4)+1);
X}
X
X/* insert space for ct chars at cursor position */
X
Xvoid spaceinline(ct) /**/
Xint ct;
X{
Xint i;
X
X	while (ct+ll > linesz)
X		line = realloc(line,(linesz *= 4)+1);
X	for (i = ll; i >= cs; i--)
X		line[i+ct] = line[i];
X	ll += ct;
X	line[ll] = '\0';
X}
X
Xvoid backkill(ct,dir) /**/
Xint ct;int dir;
X{
Xint i = (cs -= ct);
X
X	cut(i,ct,dir);
X	while (line[i] = line[i+ct])
X		i++;
X	ll -= ct;
X}
X
Xvoid forekill(ct,dir) /**/
Xint ct;int dir;
X{
Xint i = cs;
X
X	cut(i,ct,dir);
X	while (line[i] = line[i+ct])
X		i++;
X	ll -= ct;
X}
X
Xvoid cut(i,ct,dir) /**/
Xint i;int ct;int dir;
X{
X	if (vibufspec) {
X		int owrite = 1;
X		if (vibufspec >= 'A' && vibufspec <= 'Z') {
X			owrite = 0; vibufspec = tolower(vibufspec);
X		}
X		vibufspec += (idigit(vibufspec)) ? - '1' +26 : - 'a';
X		if (owrite || !vibuf[vibufspec]) {
X			if (vibuf[vibufspec]) free(vibuf[vibufspec]);
X			vibuf[vibufspec] = zalloc(ct+1);
X			ztrncpy(vibuf[vibufspec],line+i,ct);
X		} else {
X			int len = strlen(vibuf[vibufspec]);
X			vibuf[vibufspec] = realloc(vibuf[vibufspec],ct+len);
X			ztrncpy(vibuf[vibufspec]+len,line+i,ct);
X		}
X		vibufspec = 0;
X		return;
X	}
X	if (!cutbuf)
X		cutbuf = ztrdup("");
X	else if (!(lastcmd & ZLE_KILL)) {
X		kringnum = (kringnum+1)&(KRINGCT-1);
X		if (kring[kringnum])
X			free(kring[kringnum]);
X		kring[kringnum] = cutbuf;
X		cutbuf = ztrdup("");
X	}
X	if (dir) {
X		char *s = zalloc(strlen(cutbuf)+ct+1);
X		strncpy(s,line+i,ct);
X		strcpy(s+ct,cutbuf);
X		free(cutbuf);
X		cutbuf = s;
X	} else {
X		int x;
X
X		cutbuf = realloc(cutbuf,(x = strlen(cutbuf))+ct+1);
X		ztrncpy(cutbuf+x,line+i,ct);
X	}
X}
X
Xvoid backdel(ct) /**/
Xint ct;
X{
Xint i = (cs -= ct);
X
X	while (line[i] = line[i+ct])
X		i++;
X	ll -= ct;
X}
X
Xvoid foredel(ct) /**/
Xint ct;
X{
Xint i = cs;
X
X	while (line[i] = line[i+ct])
X		i++;
X	ll -= ct;
X}
X
Xvoid setline(s) /**/
Xchar *s;
X{
X	sizeline(strlen(s));
X	strcpy(line,s);
X	cs = ll = strlen(s);
X	if (cs && bindtab == altbindtab) cs--;
X}
X
Xvoid sethistline(s) /**/
Xchar *s;
X{
X	setline(s);
X	for (s = line; *s; s++)
X		if (*s == HISTSPACE)
X			*s = ' ';
X}
X
Xint findbol() /**/
X{
Xint x = cs;
X
X	while (x > 0 && line[x-1] != '\n') x--;
X	return x;
X}
X
Xint findeol() /**/
X{
Xint x = cs;
X
X	while (x != ll && line[x] != '\n') x++;
X	return x;
X}
X
Xvoid findline(a,b) /**/
Xint *a;int *b;
X{
X	*a = findbol();
X	*b = findeol();
X}
X
Xstatic int lastlinelen;
X
Xvoid initundo() /**/
X{
Xint t0;
X
X	for (t0 = 0; t0 != UNDOCT; t0++)
X		undos[t0].change = NULL;
X	undoct = 0;
X	lastline = zalloc(lastlinelen = (ll+1 < 32) ? 32 : ll+1);
X	strcpy(lastline,line);
X	lastcs = cs;
X}
X
Xvoid addundo() /**/
X{
Xint pf,sf;
Xchar *s,*s2,*t,*t2;
Xstruct undoent *ue;
X
X	for (s = line, t = lastline; *s && *s==*t; s++,t++);
X	if (!*s && !*t)
X		return;
X	pf = s-line;
X	for (s2 = line+strlen(line), t2 = lastline+strlen(lastline);
X		s2 > s && t > t2 && s2[-1] == t2[-1]; s2--,t2--);
X	sf = strlen(s2);
X	ue = undos+(undoct = (UNDOCT-1) & (undoct+1));
X	ue->pref = pf;
X	ue->suff = sf;
X	ue->len = t2-t;
X	ue->cs = lastcs;
X	strncpy(ue->change = halloc(ue->len),t,ue->len);
X	while (ll+1 > lastlinelen)
X		{
X		free(lastline);
X		lastline = zalloc(lastlinelen *= 2);
X		}
X	strcpy(lastline,line);
X	lastcs = cs;
X}
X
Xvoid freeundo() /**/
X{
X	free(lastline);
X}
X
Xint hstrncmp(s,t,len) /**/
Xchar *s;char *t;int len;
X{
X	while (len && *s && (*s == *t || (*s == ' ' && *t == HISTSPACE) ||
X			(*s == HISTSPACE && *t == ' ')))
X		s++,t++,len--;
X	return len;
X}
X
Xint hstrcmp(s,t) /**/
Xchar *s;char *t;
X{
X	while (*s && (*s == *t || (*s == ' ' && *t == HISTSPACE) ||
X			(*s == HISTSPACE && *t == ' ')))
X		s++,t++;
X	return !(*s == '\0' && *t == '\0');
X}
X
Xchar *hstrnstr(s,t,len) /**/
Xchar *s;char *t;int len;
X{
X	for (; *s; s++)
X		if (!hstrncmp(t,s,len))
X			return s;
X	return NULL;
X}
X
SHAR_EOF
chmod 0644 zsh2.1/src/zle_utils.c ||
echo 'restore of zsh2.1/src/zle_utils.c failed'
Wc_c="`wc -c < 'zsh2.1/src/zle_utils.c'`"
test 4954 -eq "$Wc_c" ||
	echo 'zsh2.1/src/zle_utils.c: original size 4954, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.1/src/zsh.h ==============
if test -f 'zsh2.1/src/zsh.h' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.1/src/zsh.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.1/src/zsh.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.1/src/zsh.h' &&
X/*
X
X	zsh.h - standard header file
X
X	This file is part of zsh, the Z shell.
X
X	zsh is free software; no one can prevent you from reading the source
X   code, or giving it to someone else.
X
X   This file is copyrighted under the GNU General Public License, which
X   can be found in the file called COPYING.
X
X   Copyright (C) 1990, 1991 Paul Falstad
X
X   zsh is distributed in the hope that it will be useful, but
X   WITHOUT ANY WARRANTY.  No author or distributor accepts
X   responsibility to anyone for the consequences of using it or for
X   whether it serves any particular purpose or works at all, unless he
X   says so in writing.  Refer to the GNU General Public License
X   for full details.
X
X   Everyone is granted permission to copy, modify and redistribute
X   zsh, but only under the conditions described in the GNU General Public
X   License.   A copy of this license is supposed to have been given to you
X   along with zsh so you can know your rights and responsibilities.
X   It should be in a file named COPYING.
X
X   Among other things, the copyright notice and this notice must be
X   preserved on all copies.
X
X*/
X
X#include "config.h"
X
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X
X#ifdef SYSV
X#include <sys/bsdtypes.h>
X#define _POSIX_SOURCE
X#include <sys/limits.h>
X#include <sys/sioctl.h>
X#define MAXPATHLEN PATH_MAX
X#define lstat stat
Xextern int gethostname();
X#define sigmask(m) m
X#include <sys/dirent.h>
Xstruct rusage { int foo; }
X#else
X#include <sys/types.h>		/* this is the key to the whole thing */
X#endif
X
X#include <sys/wait.h>
X#include <sys/time.h>
X#ifndef SYSV
X#include <sys/resource.h>
X#endif
X#include <sys/file.h>
X#include <signal.h>
X#ifdef TERMIO
X#include <sys/termio.h>
X#else
X#ifdef TERMIOS
X#include <sys/termios.h>
X#else
X#include <sgtty.h>
X#endif
X#endif
X
X#ifdef SYSV
X#undef TIOCGWINSZ
X#endif
X
X#include <sys/param.h>
X
X#ifdef SYSV
X#undef _POSIX_SOURCE
X#endif
X
X#ifdef __hp9000s800
X#include <sys/bsdtty.h>
X#endif
X
X#define VERSIONSTR "zsh v2.1.0"
X
X#if 0 /* __STDC__ */
X#include <unistd.h>
X#include <stdlib.h>
X#include <fcntl.h>
X#include <stat.h>
X#define DCLPROTO(X) X
X#undef NULL
X#define NULL ((void *)0)
X#else /* not __STDC__ */
X#include <sys/stat.h>
X#define DCLPROTO(X) ()
X#ifndef NULL
X#define NULL 0
X#endif
X#endif /* __STDC__ */
X
X#define DEFWORDCHARS "*?_-.[]~=/&;!#$%^(){}<>"
X#define DEFTIMEFMT "%E real  %U user  %S system  %P"
X#ifdef UTMP_HOST
X#define DEFWATCHFMT "%n has %a %l from %m."
X#else
X#define DEFWATCHFMT "%n has %a %l."
X#endif
X
X#ifdef GLOBALS
X#define EXTERN
X#else
X#define EXTERN extern
X#endif
X
X#ifndef F_OK
X#define F_OK 00
X#define R_OK 04
X#define W_OK 02
X#define X_OK 01
X#endif
X
X#include "zle.h"
X
X/* size of job list */
X
X#define MAXJOB 80
X
X/* memory allocation routines - changed with permalloc()/heapalloc() */
X
Xvptr (*alloc)DCLPROTO((int));
Xvptr (*ncalloc)DCLPROTO((int));
X
X#define addhnode(A,B,C,D) Addhnode(A,B,C,D,1)
X#define addhperm(A,B,C,D) Addhnode(A,B,C,D,0)
X
X/* character tokens */
X
X#define ALPOP			((char) 0x81)
X#define HISTSPACE		((char) 0x83)
X#define Pound			((char) 0x84)
X#define String			((char) 0x85)
X#define Hat				((char) 0x86)
X#define Star			((char) 0x87)
X#define Inpar			((char) 0x88)
X#define Outpar			((char) 0x89)
X#define Qstring		((char) 0x8a)
X#define Equals			((char) 0x8b)
X#define Bar				((char) 0x8c)
X#define Inbrace		((char) 0x8d)
X#define Outbrace		((char) 0x8e)
X#define Inbrack		((char) 0x8f)
X#define Outbrack		((char) 0x90)
X#define Tick			((char) 0x91)
X#define Inang			((char) 0x92)
X#define Outang			((char) 0x93)
X#define Quest			((char) 0x94)
X#define Tilde			((char) 0x95)
X#define Qtick			((char) 0x96)
X#define Comma			((char) 0x97)
X#define Nularg			((char) 0x98)
X
X/* chars that need to be quoted if meant literally */
X
X#define SPECCHARS "#$^*()$=|{}[]`<>?~;&!\n\t \\\'\""
X
X/* ALPOP in the form of a string */
X
X#define ALPOPS " \201"
X#define HISTMARK "\201"
X
X#define SEPER 1
X#define NEWLIN 2
X#define LEXERR 3
X#define SEMI 4
X#define DSEMI 5
X#define AMPER 6
X#define INPAR 7
X#define INBRACE 8
X#define OUTPAR 9
X#define DBAR 10
X#define DAMPER 11
X#define BANG 12
X#define OUTBRACE 13
X#define OUTANG 14
X#define OUTANGBANG 15
X#define DOUTANG 16
X#define DOUTANGBANG 17
X#define INANG 18
X#define DINANG 19
X#define DINANGDASH 20
X#define INANGAMP 21
X#define OUTANGAMP 22
X#define OUTANGAMPBANG 23
X#define DOUTANGAMP 24
X#define DOUTANGAMPBANG 25
X#define TRINANG 26
X#define BAR 27
X#define BARAMP 28
X#define DINBRACK 29
X#define DOUTBRACK 30
X#define STRING 31
X#define ENVSTRING 32
X#define ENVARRAY 33
X#define ENDINPUT 34
X#define INOUTPAR 35
X#define DO 36
X#define DONE 37
X#define ESAC 38
X#define THEN 39
X#define ELIF 40
X#define ELSE 41
X#define FI 42
X#define FOR 43
X#define CASE 44
X#define IF 45
X#define WHILE 46
X#define FUNC 47
X#define REPEAT 48
X#define TIME 49
X#define UNTIL 50
X#define EXEC 51
X#define COMMAND 52
X#define SELECT 53
X#define COPROC 54
X#define NOGLOB 55
X#define DASH 56
X#define NOCORRECT 57
X#define FOREACH 58
X#define ZEND 59
X
X#define WRITE 0
X#define WRITENOW 1
X#define APP 2
X#define APPNOW 3
X#define MERGEOUT 4
X#define MERGEOUTNOW 5
X#define ERRAPP 6
X#define ERRAPPNOW 7
X#define READ 8
X#define HEREDOC 9
X#define MERGE 10
X#define CLOSE 11
X#define INPIPE 12
X#define OUTPIPE 13
X#define HERESTR 14
X#define NONE 15
X#define HEREDOCDASH 16
X
X#ifdef GLOBALS
Xint redirtab[TRINANG-OUTANG+1] = {
X	WRITE,
X	WRITENOW,
X	APP,
X	APPNOW,
X	READ,
X	HEREDOC,
X	HEREDOCDASH,
X	MERGE,
X	MERGEOUT,
X	MERGEOUTNOW,
X	ERRAPP,
X	ERRAPPNOW,
X	HERESTR,
X};
X#else
Xint redirtab[TRINANG-OUTANG+1];
X#endif
X
X#define IS_READFD(X) (((X)>=READ && (X)<=MERGE)||(X)==HEREDOCDASH||(X)==HERESTR)
X#define IS_REDIROP(X) ((X)>=OUTANG && (X)<=TRINANG)
X#define IS_ERROR_REDIR(X) ((X)>=MERGEOUT && (X)<=ERRAPPNOW)
X#define UN_ERROR_REDIR(X) ((X)-MERGEOUT+WRITE)
X
XEXTERN char **environ;
X
Xtypedef struct hashtab *Hashtab;
Xtypedef struct hashnode *Hashnode;
Xtypedef struct schedcmd *Schedcmd;
Xtypedef struct alias *Alias;
Xtypedef struct process *Process;
Xtypedef struct job *Job;
Xtypedef struct value *Value;
Xtypedef struct arrind *Arrind;
Xtypedef struct varasg *Varasg;
Xtypedef struct param *Param;
Xtypedef struct cmdnam *Cmdnam;
Xtypedef struct cond *Cond;
Xtypedef struct cmd *Cmd;
Xtypedef struct pline *Pline;
Xtypedef struct sublist *Sublist;
Xtypedef struct list *List;
Xtypedef struct lklist *Lklist;
Xtypedef struct lknode *Lknode;
Xtypedef struct comp *Comp;
Xtypedef struct redir *Redir;
Xtypedef struct complist *Complist;
Xtypedef struct heap *Heap;
Xtypedef void (*FFunc)DCLPROTO((vptr));
Xtypedef vptr (*VFunc)DCLPROTO((vptr));
Xtypedef void (*HFunc)DCLPROTO((char *,char *));
X
X/* linked list abstract data type */
X
Xstruct lknode;
Xstruct lklist;
X
Xstruct lknode {
X   Lknode next,last;
X   vptr dat;
X   };
Xstruct lklist {
X   Lknode first,last;
X   };
X
X#define addnode(X,Y) insnode(X,(X)->last,Y)
X#define full(X) ((X)->first != NULL)
X#define firstnode(X) ((X)->first)
X#define getaddrdata(X) (&((X)->dat))
X#define getdata(X) ((X)->dat)
X#define setdata(X,Y) ((X)->dat = (Y))
X#define lastnode(X) ((X)->last)
X#define nextnode(X) ((X)->next)
X#define prevnode(X) ((X)->last)
X#define peekfirst(X) ((X)->first->dat)
X#define pushnode(X,Y) insnode(X,(Lknode) X,Y)
X#define incnode(X) (X = nextnode(X))
X
X/* node structure for syntax trees */
X
X/* struct list, struct sublist, struct pline, etc.  all fit the form
X	of this structure and are used interchangably
X*/
X
Xstruct node {
X	int data[4];			/* arbitrary integer data */
X	vptr ptrs[4];			/* arbitrary pointer data */
X	int types[4];			/* what ptrs[] are pointing to */
X	int type;				/* node type */
X	};
X
X#define N_LIST 0
X#define N_SUBLIST 1
X#define N_PLINE 2
X#define N_CMD 3
X#define N_REDIR 4
X#define N_COND 5
X#define N_FOR 6
X#define N_CASE 7
X#define N_IF 8
X#define N_WHILE 9
X#define N_VARASG 10
X#define N_COUNT 11
X
X/* values for types[4] */
X
X#define NT_EMPTY 0
X#define NT_NODE  1
X#define NT_STR   2
X#define NT_LIST  4
X#define NT_MALLOC 8
X
X/* tree element for lists */
X
Xstruct list {
X	int type;
X	int ifil[3];		/* to fit struct node */
X   Sublist left;
X   List right;
X   };
X
X#define SYNC 0		/* ; */
X#define ASYNC 1	/* & */
X#define TIMED 2
X
X/* tree element for sublists */
X
Xstruct sublist {
X	int type;
X	int flags;			/* see PFLAGs below */
X	int ifil[2];
X	Pline left;
X	Sublist right;
X	};
X
X#define ORNEXT 10		/* || */
X#define ANDNEXT 11	/* && */
X
X#define PFLAG_NOT 1			/* ! ... */
X#define PFLAG_COPROC 32		/* coproc ... */
X
X/* tree element for pipes */
X
Xstruct pline {
X	int type;
X	int ifil[3];
X   Cmd left;
X   Pline right;
X   };
X
X#define END		0	/* pnode *right is null */
X#define PIPE	1	/* pnode *right is the rest of the pipeline */
X
X/* tree element for commands */
X
Xstruct cmd {
X	int type;
X	int flags;				/* see CFLAGs below */
X	int ifil[2];
X   Lklist args;			/* command & argmument List (char *'s) */
X	union {
X   	List list;			/* for SUBSH/CURSH/SHFUNC */
X		struct forcmd *forcmd;
X		struct casecmd *casecmd;
X		struct ifcmd *ifcmd;
X		struct whilecmd *whilecmd;
X		Sublist pline;
X		Cond cond;
X		} u;
X   Lklist redir;			/* i/o redirections (struct redir *'s) */
X	Lklist vars;			/* param assignments (struct varasg *'s) */
X   };
X
X#define SIMPLE 0
X#define SUBSH 1
X#define ZCTIME 2
X#define CURSH 3
X#define FUNCDEF 4
X#define CFOR 5
X#define CWHILE 6
X#define CREPEAT 7
X#define CIF 8
X#define CCASE 9
X#define CSELECT 10
X#define COND 11
X
X#define CFLAG_EXEC 1			/* exec ... */
X#define CFLAG_COMMAND 2		/* command ... */
X#define CFLAG_NOGLOB 4     /* noglob ... */
X#define CFLAG_DASH 8			/* - ... */
X
X/* tree element for redirection lists */
X
Xstruct redir {
X	int type,fd1,fd2,ifil;
X	char *name;
X   };
X
X/* tree element for conditionals */
X
Xstruct cond {
X	int type;		/* can be cond_type, or a single letter (-a, -b, ...) */
X	int ifil[3];
X	vptr left,right,vfil[2];
X	int types[4],typ;	/* from struct node.  DO NOT REMOVE */
X	};
X
X#define COND_NOT 0
X#define COND_AND 1
X#define COND_OR 2
X#define COND_STREQ 3
X#define COND_STRNEQ 4
X#define COND_STRLT 5
X#define COND_STRGTR 6
X#define COND_NT 7
X#define COND_OT 8
X#define COND_EF 9
X#define COND_EQ 10
X#define COND_NE 11
X#define COND_LT 12
X#define COND_GT 13
X#define COND_LE 14
X#define COND_GE 15
X
Xstruct forcmd {		/* for/select */
X							/* Cmd->args contains list of words to loop thru */
X	int inflag;			/* if there is an in ... clause */
X	int ifil[3];
X	char *name;			/* parameter to assign values to */
X	List list;			/* list to look through for each name */
X	};
Xstruct casecmd {
X							/* Cmd->args contains word to test */
X	int ifil[4];
X	struct casecmd *next;
X	char *pat;
X	List list;					/* list to execute */
X	};
X
X/*
X
X	a command like "if foo then bar elif baz then fubar else fooble"
X	generates a tree like:
X
X	struct ifcmd a = { next =  &b,  ifl = "foo", thenl = "bar" }
X	struct ifcmd b = { next =  &c,  ifl = "baz", thenl = "fubar" }
X	struct ifcmd c = { next = NULL, ifl = NULL, thenl = "fooble" }
X
X*/
X
Xstruct ifcmd {
X	int ifil[4];
X	struct ifcmd *next;
X	List ifl;
X	List thenl;
X	};
X
Xstruct whilecmd {
X	int cond;		/* 0 for while, 1 for until */
X	int ifil[3];
X	List cont;		/* condition */
X	List loop;		/* list to execute until condition met */
X	};
X
X/* structure used for multiple i/o redirection */
X/* one for each fd open */
X
Xstruct multio {
X	int ct;				/* # of redirections on this fd */
X	int rflag;			/* 0 if open for reading, 1 if open for writing */
X	int pipe;			/* fd of pipe if ct > 1 */
X	int fds[NOFILE];	/* list of src/dests redirected to/from this fd */
X   }; 
X
X/* node used in command path hash table (cmdnamtab) */
X
Xstruct cmdnam 
X{
X	int type,flags;
X	int ifil[2];
X	union {
X		char *nam;		/* full pathname if type != BUILTIN */
X		int binnum;		/* func to exec if type == BUILTIN */
X		List list;		/* list to exec if type == SHFUNC */
X		} u;
X	};
X
X#define EXCMD_PREDOT 0
X#define EXCMD_POSTDOT 1
X#define BUILTIN 2
X#define SHFUNC 3
X#define DISABLED 4
X#define ISEXCMD(X) ((X)==EXCMD_PREDOT||(X)==EXCMD_POSTDOT)
X
X/* node used in parameter hash table (paramtab) */
X
Xstruct param {
X	union {
X		char **arr;		/* value if declared array */
X		char *str;		/* value if declared string (scalar) */
X		long val;		/* value if declared integer */
X		} u;
X	union {				/* functions to call to set value */
X		void (*cfn)DCLPROTO((Param,char *));
X		void (*ifn)DCLPROTO((Param,long));
X		void (*afn)DCLPROTO((Param,char **));
X		} sets;
X	union {				/* functions to call to get value */
X		char *(*cfn)DCLPROTO((Param));
X		long (*ifn)DCLPROTO((Param));
X		char **(*afn)DCLPROTO((Param));
X		} gets;
X	int ct;				/* output base or field width */
X	int flags;
X	vptr data;			/* used by getfns */
X	char *env;			/* location in environment, if exported */
X	char *ename;		/* name of corresponding environment var */
X	};
X
X#define PMFLAG_s 0		/* scalar */
X#define PMFLAG_L 1		/* left justify and remove leading blanks */
X#define PMFLAG_R 2		/* right justify and fill with leading blanks */
X#define PMFLAG_Z 4		/* right justify and fill with leading zeros */
X#define PMFLAG_i 8		/* integer */
X#define PMFLAG_l 16		/* all lower case */
X#define PMFLAG_u 32		/* all upper case */
X#define PMFLAG_r 64		/* readonly */
X#define PMFLAG_t 128		/* tagged */
X#define PMFLAG_x 256		/* exported */
X#define PMFLAG_A 512		/* array */
X#define PMFLAG_SPECIAL	1024
X#define PMTYPE (PMFLAG_i|PMFLAG_A)
X#define pmtype(X) ((X)->flags & PMTYPE)
X
X/* variable assignment tree element */
X
Xstruct varasg {
X	int type;			/* nonzero means array */
X	int ifil[3];
X	char *name;
X	char *str;			/* should've been a union here.  oh well */
X	Lklist arr;
X	};
X
X/* lvalue for variable assignment/expansion */
X
Xstruct value {
X	int isarr;
X	struct param *pm;		/* parameter node */
X	int a;					/* first element of array slice, or -1 */
X	int b;					/* last element of array slice, or -1 */
X	};
X
Xstruct fdpair {
X	int fd1,fd2;
X	};
X
X/* tty state structure */
X
Xstruct ttyinfo {
X#ifdef TERMIOS
X	struct termios termios;
X#else
X#ifdef TERMIO
X	struct termio termio;
X#else
X	struct sgttyb sgttyb;
X	int lmodes;
X	struct tchars tchars;
X	struct ltchars ltchars;
X#endif
X#endif
X#ifdef TIOCGWINSZ
X	struct winsize winsize;
X#endif
X	};
X
XEXTERN struct ttyinfo savedttyinfo;
X
X/* entry in job table */
X
Xstruct job {
X	long gleader;					/* process group leader of this job */
X	int stat;
X	char *cwd;						/* current working dir of shell when
X											this job was spawned */
X	struct process *procs;		/* list of processes */
X	Lklist filelist;				/* list of files to delete when done */
X	};
X
X#define STAT_CHANGED 1		/* status changed and not reported */
X#define STAT_STOPPED 2		/* all procs stopped or exited */
X#define STAT_TIMED 4			/* job is being timed */
X#define STAT_DONE 8
X#define STAT_LOCKED 16		/* shell is finished creating this job,
X										may be deleted from job table */
X#define STAT_INUSE 64		/* this job entry is in use */
X
X#define SP_RUNNING -1		/* fake statusp for running jobs */
X
X/* node in job process lists */
X
Xstruct process {
X	struct process *next;
X	long pid;
X	char *text;						/* text to print when 'jobs' is run */
X	int statusp;					/* return code from wait3() */
X	int lastfg;						/* set if this process represents a
X											fragment of a pipeline run in a subshell
X											for commands like:
X
X											foo | bar | ble
X
X											where foo is a current shell function
X											or control structure.  The command
X											actually executed is:
X
X											foo | (bar | ble)
X
X											That's two procnodes in the parent
X											shell, the latter having this flag set. */
X	struct rusage ru;
X	time_t bgtime;					/* time job was spawned */
X	time_t endtime;				/* time job exited */
X	};
X
X/* node in alias hash table */
X
Xstruct alias {
X	char *text;			/* expansion of alias */
X	int cmd;				/* one for regular aliases,
X								zero for global aliases,
X								negative for reserved words */
X	int inuse;			/* alias is being expanded */
X	};
X
X/* node in sched list */
X
Xstruct schedcmd {
X	struct schedcmd *next;
X	char *cmd;		/* command to run */
X	time_t time;	/* when to run it */
X	};
X
X#define MAXAL 20	/* maximum number of aliases expanded at once */
X
X/* hash table node */
X
Xstruct hashnode {
X	struct hashnode *next;
X	char *nam;
X	vptr dat;
X	int canfree;		/* nam is free()able */
X	};
X
X/* hash table */
X
Xstruct hashtab {
X	int hsize;							/* size of nodes[] */
X	int ct;								/* # of elements */
X	struct hashnode **nodes;		/* array of size hsize */
X	};
X
Xextern char *sys_errlist[];
Xextern int errno;
X
X/* values in opts[] array */
X
X#define OPT_INVALID 1	/* opt is invalid, like -$ */
X#define OPT_UNSET 0
X#define OPT_SET 2
X
X/* the options */
X
Xstruct option {
X	char *name;
X	char id;			/* corresponding letter */
X	};
X
X#define CORRECT '0'
X#define NOCLOBBER '1'
X#define NOBADPATTERN '2'
X#define NONOMATCH '3'
X#define GLOBDOTS '4'
X#define NOTIFY '5'
X#define BGNICE '6'
X#define IGNOREEOF '7'
X#define MARKDIRS '8'
X#define AUTOLIST '9'
X#define NOBEEP 'B'
X#define PRINTEXITVALUE 'C'
X#define PUSHDTOHOME 'D'
X#define PUSHDSILENT 'E'
X#define NOGLOBOPT 'F'
X#define NULLGLOB 'G'
X#define RMSTARSILENT 'H'
X#define IGNOREBRACES 'I'
X#define AUTOCD 'J'
X#define NOBANGHIST 'K'
X#define SUNKEYBOARDHACK 'L'
X#define SINGLELINEZLE 'M'
X#define AUTOPUSHD 'N'
X#define CORRECTALL 'O'
X#define RCEXPANDPARAM 'P'
X#define PATHDIRS 'Q'
X#define LONGLISTJOBS 'R'
X#define RECEXACT 'S'
X#define CDABLEVARS 'T'
X#define MAILWARNING 'U'
X#define NOPROMPTCLOBBER 'V'
X#define AUTORESUME 'W'
X#define LISTTYPES 'X'
SHAR_EOF
true || echo 'restore of zsh2.1/src/zsh.h failed'
fi
echo 'End of zsh2.1.0 part 12'
echo 'File zsh2.1/src/zsh.h is continued in part 13'
echo 13 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
-- 
Kent Landfield                   INTERNET: kent@sparky.IMD.Sterling.COM
Sterling Software, IMD           UUCP:     uunet!sparky!kent
Phone:    (402) 291-8300         FAX:      (402) 291-4362
Please send comp.sources.misc-related mail to kent@uunet.uu.net.
